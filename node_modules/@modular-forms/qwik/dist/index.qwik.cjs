"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const qwik = require("@builder.io/qwik");
const qwikCity = require("@builder.io/qwik-city");
const requestHandler = require("@builder.io/qwik-city/middleware/request-handler");
const build = require("@builder.io/qwik/build");
class FormError extends Error {
  constructor(arg1, arg2) {
    super(typeof arg1 === "string" ? arg1 : "");
    __publicField(this, "name", "FormError");
    __publicField(this, "errors");
    this.errors = typeof arg1 === "string" ? arg2 || {} : arg1;
  }
}
function getElementInput(element, field, type) {
  const { checked, files, options, value: value2, valueAsDate, valueAsNumber } = element;
  return !type || type === "string" ? value2 : type === "string[]" ? options ? [
    ...options
  ].filter((e) => e.selected && !e.disabled).map((e) => e.value) : checked ? [
    ...field.value || [],
    value2
  ] : (field.value || []).filter((v) => v !== value2) : type === "number" ? valueAsNumber : type === "boolean" ? checked : type === "File" && files ? qwik.noSerialize(files[0]) : type === "File[]" && files ? [
    ...files
  ].map((file) => qwik.noSerialize(file)) : type === "Date" && valueAsDate ? valueAsDate : field.value;
}
function getFieldAndArrayStores(form) {
  return [
    ...Object.values(form.internal.fields),
    ...Object.values(form.internal.fieldArrays)
  ];
}
function getFieldArrayStore(form, name) {
  return form.internal.fieldArrays[name];
}
function getPathIndex(name, path) {
  return +path.replace(`${name}.`, "").split(".")[0];
}
function removeInvalidNames(form, names) {
  getFieldArrayNames(form, false).forEach((fieldArrayName) => {
    const lastIndex = getFieldArrayStore(form, fieldArrayName).items.length - 1;
    names.filter((name) => name.startsWith(`${fieldArrayName}.`) && getPathIndex(fieldArrayName, name) > lastIndex).forEach((name) => {
      names.splice(names.indexOf(name), 1);
    });
  });
}
function getFieldArrayNames(form, shouldValid = true) {
  const fieldArrayNames = Object.keys(form.internal.fieldArrays);
  if (shouldValid)
    removeInvalidNames(form, fieldArrayNames);
  return fieldArrayNames;
}
function getFieldArrayState(form, name) {
  const fieldArray = getFieldArrayStore(form, name);
  return fieldArray ? {
    startItems: fieldArray.internal.startItems,
    items: fieldArray.items,
    error: fieldArray.error,
    touched: fieldArray.touched,
    dirty: fieldArray.dirty
  } : void 0;
}
function getFieldNames(form, shouldValid = true) {
  const fieldNames = Object.keys(form.internal.fields);
  if (shouldValid)
    removeInvalidNames(form, fieldNames);
  return fieldNames;
}
function getFieldStore(form, name) {
  return form.internal.fields[name];
}
function getFieldState(form, name) {
  const field = getFieldStore(form, name);
  return field ? {
    startValue: field.internal.startValue,
    value: field.value,
    error: field.error,
    touched: field.touched,
    dirty: field.dirty
  } : void 0;
}
function getFilteredNames(form, arg2, shouldValid) {
  const allFieldNames = getFieldNames(form, shouldValid);
  const allFieldArrayNames = getFieldArrayNames(form, shouldValid);
  if (typeof arg2 === "string" || Array.isArray(arg2))
    return (typeof arg2 === "string" ? [
      arg2
    ] : arg2).reduce((tuple, name) => {
      const [fieldNames, fieldArrayNames] = tuple;
      if (allFieldArrayNames.includes(name)) {
        allFieldArrayNames.forEach((fieldArrayName) => {
          if (fieldArrayName.startsWith(name))
            fieldArrayNames.add(fieldArrayName);
        });
        allFieldNames.forEach((fieldName) => {
          if (fieldName.startsWith(name))
            fieldNames.add(fieldName);
        });
      } else
        fieldNames.add(name);
      return tuple;
    }, [
      /* @__PURE__ */ new Set(),
      /* @__PURE__ */ new Set()
    ]).map((set) => [
      ...set
    ]);
  return [
    allFieldNames,
    allFieldArrayNames
  ];
}
function getFormDataValues(formData, formDataInfo = {}) {
  const { arrays = [], booleans = [], dates = [], files = [], numbers = [] } = formDataInfo;
  const getTemplateName = (name) => name.replace(/.\d+./g, ".$.");
  const values = [
    ...formData.entries()
  ].reduce((values2, [name, value2]) => {
    const template = getTemplateName(name);
    const getDate = () => (
      // Date (yyyy-mm-dd)
      /^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])$/.test(value2) ? /* @__PURE__ */ new Date(`${value2}T00:00:00.000Z`) : /^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(1\d|0[0-9]|2[0-3]):[0-5]\d$/.test(value2) ? /* @__PURE__ */ new Date(`${value2}:00.000Z`) : /^\d{4}-W(0[1-9]|[1-4]\d|5[0-3])$/.test(value2) ? (() => {
        const [year, week] = value2.split("-W");
        const date = /* @__PURE__ */ new Date(`${year}-01-01T00:00:00.000Z`);
        date.setUTCDate((+week - 1) * 7 + 1);
        return date;
      })() : /^(1\d|0[0-9]|2[0-3]):[0-5]\d$/.test(value2) ? /* @__PURE__ */ new Date(`1970-01-01T${value2}:00.000Z`) : /^(1\d|0[0-9]|2[0-3]):[0-5]\d:[0-5]\d$/.test(value2) ? /* @__PURE__ */ new Date(`1970-01-01T${value2}.000Z`) : new Date(value2)
    );
    const getValue2 = () => booleans.includes(template) ? true : dates.includes(template) ? getDate() : files.includes(template) && typeof value2 !== "string" ? qwik.noSerialize(value2) : numbers.includes(template) ? /^-?\d*(\.\d+)?$/.test(value2) ? parseFloat(value2) : getDate().getTime() : value2;
    name.split(".").reduce((object, key, index, keys) => {
      if (index < keys.length - 1)
        return object[key] = object[key] || (isNaN(+keys[index + 1]) ? {} : []);
      if (!files.includes(template) || value2 && (typeof value2 === "string" || value2.size)) {
        if (arrays.includes(template)) {
          object[key] = object[key] || [];
          object[key].push(getValue2());
        } else
          object[key] = getValue2();
      }
    }, values2);
    return values2;
  }, {});
  const getParentOfPath = (keys) => {
    return keys.slice(0, -1).reduce((object, key, index) => object[key] = object[key] || (isNaN(+keys[index + 1]) ? {} : []), values);
  };
  [
    .../* @__PURE__ */ new Set([
      ...arrays,
      ...booleans
    ])
  ].sort().forEach((path) => {
    const paths = [];
    if (path.includes(".$.")) {
      const addArrayPaths = (currentPath, parentPath) => {
        const [präfixPath, ...suffixPaths] = currentPath.split(".$.");
        const suffixPath = suffixPaths.join(".$.");
        const arrayPath = parentPath ? `${parentPath}.${präfixPath}` : präfixPath;
        getParentOfPath([
          ...arrayPath.split("."),
          "0"
        ]).map((_, index) => {
          const indexPath = `${arrayPath}.${index}`;
          if (suffixPaths.length > 1)
            addArrayPaths(suffixPath, indexPath);
          else
            paths.push(`${indexPath}.${suffixPath}`);
        });
      };
      addArrayPaths(path);
    } else
      paths.push(path);
    paths.forEach((path2) => {
      const template = getTemplateName(path2);
      const keys = path2.split(".");
      const lastKey = keys[keys.length - 1];
      const object = getParentOfPath(keys);
      if (arrays.includes(template))
        object[lastKey] = object[lastKey] || [];
      else
        object[lastKey] = !!object[lastKey];
    });
  });
  return values;
}
function getInitialFieldArrayStore(name, { items, initialItems, error } = {
  items: [],
  initialItems: [],
  error: ""
}) {
  const dirty = initialItems.join() !== items.join();
  return {
    internal: {
      initialItems: [
        ...initialItems
      ],
      startItems: [
        ...initialItems
      ],
      validate: [],
      consumers: []
    },
    name,
    items,
    error,
    active: false,
    touched: dirty,
    dirty
  };
}
function isFieldDirty(startValue, currentValue) {
  const toValue = (item) => item instanceof Blob ? item.size : item;
  return Array.isArray(startValue) && Array.isArray(currentValue) ? startValue.map(toValue).join() !== currentValue.map(toValue).join() : startValue instanceof Date && currentValue instanceof Date ? startValue.getTime() !== currentValue.getTime() : Number.isNaN(startValue) && Number.isNaN(currentValue) ? false : startValue !== currentValue;
}
function getInitialFieldStore(name, { value: value2, initialValue, error } = {
  value: void 0,
  initialValue: void 0,
  error: ""
}) {
  const dirty = isFieldDirty(initialValue, value2);
  return {
    internal: {
      initialValue,
      startValue: initialValue,
      validate: [],
      transform: [],
      elements: [],
      consumers: []
    },
    name,
    value: value2,
    error,
    active: false,
    touched: dirty,
    dirty
  };
}
function getPathValue(path, object) {
  return path.split(".").reduce((value2, key) => value2?.[key], object);
}
let counter = 0;
function getUniqueId() {
  return counter++;
}
function getInitialStores({ loader, action, fieldArrays }) {
  function getActionValue(name) {
    return action?.value?.values && getPathValue(name, action.value.values);
  }
  const generateItems = () => getUniqueId();
  const getActionError = (name) => action?.value?.errors[name] || "";
  const createInitialStores = (stores, data, prevPath) => Object.entries(data).reduce((stores2, [path, value2]) => {
    const compoundPath = prevPath ? `${prevPath}.${path}` : path;
    if (fieldArrays?.includes(compoundPath.replace(/.\d+./g, ".$."))) {
      const initialItems = value2.map(generateItems);
      stores2[1][compoundPath] = getInitialFieldArrayStore(compoundPath, {
        initialItems,
        items: getActionValue(compoundPath)?.map(generateItems) || [
          ...initialItems
        ],
        error: getActionError(compoundPath)
      });
    } else if (!value2 || typeof value2 !== "object" || Array.isArray(value2) || value2 instanceof Date)
      stores2[0][compoundPath] = getInitialFieldStore(compoundPath, {
        initialValue: value2,
        value: getActionValue(compoundPath) ?? value2,
        error: getActionError(compoundPath)
      });
    if (value2 && typeof value2 === "object")
      createInitialStores(stores2, value2, compoundPath);
    return stores2;
  }, stores);
  return createInitialStores([
    {},
    {}
  ], loader.value);
}
async function getParsedZodSchema(schema, value2) {
  const zodSchema = await schema.resolve();
  return (typeof zodSchema === "function" ? zodSchema() : zodSchema).safeParse(value2);
}
function getOptions(arg1, arg2) {
  return (typeof arg1 !== "string" && !Array.isArray(arg1) ? arg1 : arg2) || {};
}
function updateFormDirty(form, dirty) {
  form.dirty = dirty || getFieldAndArrayStores(form).some((fieldOrFieldArray) => fieldOrFieldArray.active && fieldOrFieldArray.dirty);
}
function updateFieldDirty(form, field) {
  const dirty = isFieldDirty(field.internal.startValue, field.value);
  if (dirty !== field.dirty) {
    field.dirty = dirty;
    updateFormDirty(form, dirty);
  }
}
function focus(form, name) {
  getFieldStore(form, name)?.internal.elements[0]?.focus();
}
function setError(form, name, error, { shouldActive = true, shouldTouched = false, shouldDirty = false, shouldFocus = !!error } = {}) {
  for (const fieldOrFieldArray of [
    getFieldStore(form, name),
    getFieldArrayStore(form, name)
  ])
    if (fieldOrFieldArray && (!shouldActive || fieldOrFieldArray.active) && (!shouldTouched || fieldOrFieldArray.touched) && (!shouldDirty || fieldOrFieldArray.dirty)) {
      fieldOrFieldArray.error = error;
      if (error && "value" in fieldOrFieldArray && shouldFocus)
        focus(form, name);
    }
  updateFormInvalid(form, !!error);
}
function clearError(form, name, options) {
  setError(form, name, "", options);
}
function clearResponse(form) {
  form.response = {};
}
function getError(form, name, { shouldActive = true, shouldTouched = false, shouldDirty = false } = {}) {
  for (const fieldOrFieldArray of [
    getFieldStore(form, name),
    getFieldArrayStore(form, name)
  ]) {
    if (fieldOrFieldArray && (!shouldActive || fieldOrFieldArray.active) && (!shouldTouched || fieldOrFieldArray.touched) && (!shouldDirty || fieldOrFieldArray.dirty))
      return fieldOrFieldArray.error;
  }
  return void 0;
}
function getErrors(form, arg2, arg3) {
  const [fieldNames, fieldArrayNames] = getFilteredNames(form, arg2);
  const { shouldActive = true, shouldTouched = false, shouldDirty = false } = getOptions(arg2, arg3);
  return [
    ...fieldNames.map((name) => [
      name,
      getFieldStore(form, name)
    ]),
    ...fieldArrayNames.map((name) => [
      name,
      getFieldArrayStore(form, name)
    ])
  ].reduce((formErrors, [name, fieldOrFieldArray]) => {
    if (fieldOrFieldArray.error && (!shouldActive || fieldOrFieldArray.active) && (!shouldTouched || fieldOrFieldArray.touched) && (!shouldDirty || fieldOrFieldArray.dirty))
      formErrors[name] = fieldOrFieldArray.error;
    return formErrors;
  }, {});
}
function getValue(form, name, { shouldActive = true, shouldTouched = false, shouldDirty = false, shouldValid = false } = {}) {
  const field = getFieldStore(form, name);
  if (field && (!shouldActive || field.active) && (!shouldTouched || field.touched) && (!shouldDirty || field.dirty) && (!shouldValid || !field.error))
    return field.value;
  return void 0;
}
function getValues(form, arg2, arg3) {
  const { shouldActive = true, shouldTouched = false, shouldDirty = false, shouldValid = false } = getOptions(arg2, arg3);
  return getFilteredNames(form, arg2)[0].reduce((values, name) => {
    const field = getFieldStore(form, name);
    if ((!shouldActive || field.active) && (!shouldTouched || field.touched) && (!shouldDirty || field.dirty) && (!shouldValid || !field.error))
      (typeof arg2 === "string" ? name.replace(`${arg2}.`, "") : name).split(".").reduce((object, key, index, keys) => object[key] = index === keys.length - 1 ? field.value : typeof object[key] === "object" && object[key] || (isNaN(+keys[index + 1]) ? {} : []), values);
    return values;
  }, typeof arg2 === "string" ? [] : {});
}
function hasField(form, name, { shouldActive = true, shouldTouched = false, shouldDirty = false, shouldValid = false } = {}) {
  const field = getFieldStore(form, name);
  return !!field && (!shouldActive || field.active) && (!shouldTouched || field.touched) && (!shouldDirty || field.dirty) && (!shouldValid || !field.error);
}
function hasFieldArray(form, name, { shouldActive = true, shouldTouched = false, shouldDirty = false, shouldValid = false } = {}) {
  const fieldArray = getFieldArrayStore(form, name);
  return !!fieldArray && (!shouldActive || fieldArray.active) && (!shouldTouched || fieldArray.touched) && (!shouldDirty || fieldArray.dirty) && (!shouldValid || !fieldArray.error);
}
function insert(form, name, options) {
  const fieldArray = getFieldArrayStore(form, name);
  if (fieldArray) {
    const arrayLength = fieldArray.items.length;
    const { at: index = arrayLength, value: value2 } = options;
    if (index >= 0 && index <= arrayLength) {
      if (index < arrayLength) {
        const filterName = (value22) => value22.startsWith(`${name}.`) && getPathIndex(name, value22) >= index;
        const getNextIndexName = (fieldOrFieldArrayName, fieldOrFieldArrayIndex) => fieldOrFieldArrayName.replace(`${name}.${fieldOrFieldArrayIndex}`, `${name}.${fieldOrFieldArrayIndex + 1}`);
        getFieldNames(form).filter(filterName).sort(sortArrayPathIndex(name)).reverse().forEach((fieldName) => {
          setFieldState(form, getNextIndexName(fieldName, getPathIndex(name, fieldName)), getFieldState(form, fieldName));
        });
        getFieldArrayNames(form).filter(filterName).sort(sortArrayPathIndex(name)).reverse().forEach((fieldArrayName) => {
          setFieldArrayState(form, getNextIndexName(fieldArrayName, getPathIndex(name, fieldArrayName)), getFieldArrayState(form, fieldArrayName));
        });
      }
      setFieldArrayValue(form, name, {
        at: index,
        value: value2
      });
      fieldArray.items.splice(index, 0, getUniqueId());
      fieldArray.touched = true;
      form.touched = true;
      fieldArray.dirty = true;
      form.dirty = true;
      setTimeout(() => validateIfRequired(form, fieldArray, name, {
        on: [
          "touched",
          "input"
        ]
      }), 250);
    }
  }
}
function move(form, name, { from: fromIndex, to: toIndex }) {
  const fieldArray = getFieldArrayStore(form, name);
  if (fieldArray) {
    const lastIndex = fieldArray.items.length - 1;
    if (fromIndex >= 0 && fromIndex <= lastIndex && toIndex >= 0 && toIndex <= lastIndex && fromIndex !== toIndex) {
      const filterName = (value2) => {
        if (value2.startsWith(name)) {
          const fieldIndex = getPathIndex(name, value2);
          return fieldIndex >= fromIndex && fieldIndex <= toIndex || fieldIndex <= fromIndex && fieldIndex >= toIndex;
        }
      };
      const getPrevIndexName = (fieldOrFieldArrayName, fieldOrFieldArrayIndex) => fieldOrFieldArrayName.replace(`${name}.${fieldOrFieldArrayIndex}`, fromIndex < toIndex ? `${name}.${fieldOrFieldArrayIndex - 1}` : `${name}.${fieldOrFieldArrayIndex + 1}`);
      const getToIndexName = (fieldOrFieldArrayName) => fieldOrFieldArrayName.replace(`${name}.${fromIndex}`, `${name}.${toIndex}`);
      const fieldNames = getFieldNames(form).filter(filterName).sort(sortArrayPathIndex(name));
      const fieldArrayNames = getFieldArrayNames(form).filter(filterName).sort(sortArrayPathIndex(name));
      if (fromIndex > toIndex) {
        fieldNames.reverse();
        fieldArrayNames.reverse();
      }
      const fieldStateMap = /* @__PURE__ */ new Map();
      const fieldArrayStateMap = /* @__PURE__ */ new Map();
      fieldNames.forEach((fieldName) => {
        const fieldState = getFieldState(form, fieldName);
        const fieldIndex = getPathIndex(name, fieldName);
        if (fieldIndex === fromIndex)
          fieldStateMap.set(fieldName, fieldState);
        else
          setFieldState(form, getPrevIndexName(fieldName, fieldIndex), fieldState);
      });
      fieldStateMap.forEach((fieldState, fieldName) => {
        setFieldState(form, getToIndexName(fieldName), fieldState);
      });
      fieldArrayNames.forEach((fieldArrayName) => {
        const fieldArrayState = getFieldArrayState(form, fieldArrayName);
        const fieldArrayIndex = getPathIndex(name, fieldArrayName);
        if (fieldArrayIndex === fromIndex)
          fieldArrayStateMap.set(fieldArrayName, fieldArrayState);
        else
          setFieldArrayState(form, getPrevIndexName(fieldArrayName, fieldArrayIndex), fieldArrayState);
      });
      fieldArrayStateMap.forEach((fieldArrayState, fieldArrayName) => {
        setFieldArrayState(form, getToIndexName(fieldArrayName), fieldArrayState);
      });
      fieldArray.items.splice(toIndex, 0, fieldArray.items.splice(fromIndex, 1)[0]);
      fieldArray.touched = true;
      form.touched = true;
      updateFieldArrayDirty(form, fieldArray);
    }
  }
}
function remove(form, name, { at: index }) {
  const fieldArray = getFieldArrayStore(form, name);
  if (fieldArray) {
    const lastIndex = fieldArray.items.length - 1;
    if (index >= 0 && index <= lastIndex) {
      const filterName = (value2) => value2.startsWith(`${name}.`) && getPathIndex(name, value2) > index;
      const getPrevIndexName = (fieldOrFieldArrayName, fieldOrFieldArrayIndex) => fieldOrFieldArrayName.replace(`${name}.${fieldOrFieldArrayIndex}`, `${name}.${fieldOrFieldArrayIndex - 1}`);
      getFieldNames(form).filter(filterName).sort(sortArrayPathIndex(name)).forEach((fieldName) => {
        setFieldState(form, getPrevIndexName(fieldName, getPathIndex(name, fieldName)), getFieldState(form, fieldName));
      });
      getFieldArrayNames(form).filter(filterName).sort(sortArrayPathIndex(name)).forEach((fieldArrayName) => {
        setFieldArrayState(form, getPrevIndexName(fieldArrayName, getPathIndex(name, fieldArrayName)), getFieldArrayState(form, fieldArrayName));
      });
      fieldArray.items.splice(index, 1);
      fieldArray.touched = true;
      form.touched = true;
      updateFieldArrayDirty(form, fieldArray);
      validateIfRequired(form, fieldArray, name, {
        on: [
          "touched",
          "input"
        ]
      });
    }
  }
}
function replace(form, name, options) {
  const fieldArray = getFieldArrayStore(form, name);
  if (fieldArray) {
    const { at: index } = options;
    const lastIndex = fieldArray.items.length - 1;
    if (index >= 0 && index <= lastIndex) {
      setFieldArrayValue(form, name, options);
      fieldArray.items[index] = getUniqueId();
      fieldArray.touched = true;
      form.touched = true;
      fieldArray.dirty = true;
      form.dirty = true;
    }
  }
}
function reset(form, arg2, arg3) {
  const [fieldNames, fieldArrayNames] = getFilteredNames(form, arg2, false);
  const resetSingleField = typeof arg2 === "string" && fieldNames.length === 1;
  const resetEntireForm = !resetSingleField && !Array.isArray(arg2);
  const options = getOptions(arg2, arg3);
  const { initialValue, initialValues, keepResponse = false, keepSubmitCount = false, keepSubmitted = false, keepValues = false, keepDirtyValues = false, keepItems = false, keepDirtyItems = false, keepErrors = false, keepTouched = false, keepDirty = false } = options;
  fieldNames.forEach((name) => {
    const field = getFieldStore(form, name);
    if (resetSingleField ? "initialValue" in options : initialValues)
      field.internal.initialValue = resetSingleField ? initialValue : getPathValue(name, initialValues);
    const keepDirtyValue = keepDirtyValues && field.dirty;
    if (!keepValues && !keepDirtyValue) {
      field.internal.startValue = field.internal.initialValue;
      field.value = field.internal.initialValue;
      field.internal.elements.forEach((element) => {
        if (element.type === "file")
          element.value = "";
      });
    }
    if (!keepTouched)
      field.touched = false;
    if (!keepDirty && !keepValues && !keepDirtyValue)
      field.dirty = false;
    if (!keepErrors)
      field.error = "";
  });
  fieldArrayNames.forEach((name) => {
    const fieldArray = getFieldArrayStore(form, name);
    const keepCurrentDirtyItems = keepDirtyItems && fieldArray.dirty;
    if (!keepItems && !keepCurrentDirtyItems) {
      if (initialValues)
        fieldArray.internal.initialItems = getPathValue(name, initialValues)?.map(() => getUniqueId()) || [];
      fieldArray.internal.startItems = [
        ...fieldArray.internal.initialItems
      ];
      fieldArray.items = [
        ...fieldArray.internal.initialItems
      ];
    }
    if (!keepTouched)
      fieldArray.touched = false;
    if (!keepDirty && !keepItems && !keepCurrentDirtyItems)
      fieldArray.dirty = false;
    if (!keepErrors)
      fieldArray.error = "";
  });
  if (resetEntireForm) {
    if (!keepResponse)
      form.response = {};
    if (!keepSubmitCount)
      form.submitCount = 0;
    if (!keepSubmitted)
      form.submitted = false;
  }
  updateFormState(form);
}
function setResponse(form, response, { duration } = {}) {
  form.response = response;
  if (duration)
    setTimeout(() => {
      if (form.response === response)
        form.response = {};
    }, duration);
}
function setValue(form, name, value2, { shouldTouched = true, shouldDirty = true, shouldValidate = true, shouldFocus = true } = {}) {
  const field = initializeFieldStore(form, name);
  field.value = value2;
  if (shouldTouched) {
    field.touched = true;
    form.touched = true;
  }
  if (shouldDirty)
    updateFieldDirty(form, field);
  if (shouldValidate)
    validateIfRequired(form, field, name, {
      on: [
        "touched",
        "input"
      ],
      shouldFocus
    });
}
async function validate(form, arg2, arg3) {
  const [fieldNames, fieldArrayNames] = getFilteredNames(form, arg2);
  const { shouldActive = true, shouldFocus = true } = getOptions(arg2, arg3);
  const validator = getUniqueId();
  form.internal.validators.push(validator);
  form.validating = true;
  const formErrors = form.internal.validate ? await form.internal.validate(getValues(form, {
    shouldActive
  })) : {};
  let valid = typeof arg2 !== "string" && !Array.isArray(arg2) ? !Object.keys(formErrors).length : true;
  const [errorFields] = await Promise.all([
    // Validate each field in list
    Promise.all(fieldNames.map(async (name) => {
      const field = getFieldStore(form, name);
      if (!shouldActive || field.active) {
        let localError;
        for (const validation of field.internal.validate) {
          localError = await validation(field.value);
          if (localError)
            break;
        }
        const fieldError = localError || formErrors[name] || "";
        if (fieldError)
          valid = false;
        field.error = fieldError;
        return fieldError ? name : null;
      }
    })),
    // Validate each field array in list
    Promise.all(fieldArrayNames.map(async (name) => {
      const fieldArray = getFieldArrayStore(form, name);
      if (!shouldActive || fieldArray.active) {
        let localError = "";
        for (const validation of fieldArray.internal.validate) {
          localError = await validation(fieldArray.items);
          if (localError)
            break;
        }
        const fieldArrayError = localError || formErrors[name] || "";
        if (fieldArrayError)
          valid = false;
        fieldArray.error = fieldArrayError;
      }
    }))
  ]);
  setErrorResponse(form, formErrors, {
    shouldActive
  });
  if (shouldFocus) {
    const name = errorFields.find((name2) => name2);
    if (name)
      focus(form, name);
  }
  updateFormInvalid(form, !valid);
  form.internal.validators.splice(form.internal.validators.indexOf(validator), 1);
  if (!form.internal.validators.length)
    form.validating = false;
  return valid;
}
function setValues(form, arg2, arg3, arg4) {
  const isFieldArray = typeof arg2 === "string";
  const values = isFieldArray ? arg3 : arg2;
  const options = (isFieldArray ? arg4 : arg3) || {};
  const { shouldTouched = true, shouldDirty = true, shouldValidate = true, shouldFocus = true } = options;
  const names = isFieldArray ? [
    arg2
  ] : [];
  const setFieldArrayItems = (name, value2) => {
    const fieldArray = initializeFieldArrayStore(form, name);
    fieldArray.items = value2.map(() => getUniqueId());
    if (shouldTouched) {
      fieldArray.touched = true;
      form.touched = true;
    }
    if (shouldDirty) {
      fieldArray.dirty = true;
      form.dirty = true;
    }
  };
  const setNestedValues = (data, prevPath) => Object.entries(data).forEach(([path, value2]) => {
    const compoundPath = prevPath ? `${prevPath}.${path}` : path;
    if (!value2 || typeof value2 !== "object" || Array.isArray(value2)) {
      setValue(form, compoundPath, value2, {
        ...options,
        shouldValidate: false
      });
      names.push(compoundPath);
    }
    if (Array.isArray(value2))
      setFieldArrayItems(compoundPath, value2);
    if (value2 && typeof value2 === "object")
      setNestedValues(value2, compoundPath);
  });
  if (isFieldArray)
    setFieldArrayItems(arg2, arg3);
  setNestedValues(values, isFieldArray ? arg2 : void 0);
  if (shouldValidate && [
    "touched",
    "input"
  ].includes(form.internal.validateOn === "submit" && form.submitted ? form.internal.revalidateOn : form.internal.validateOn))
    validate(form, names, {
      shouldFocus
    });
}
function submit(form) {
  form.element?.requestSubmit();
}
function swap(form, name, { at: index1, and: index2 }) {
  const fieldArray = getFieldArrayStore(form, name);
  if (fieldArray) {
    const lastIndex = fieldArray.items.length - 1;
    if (index1 >= 0 && index1 <= lastIndex && index2 >= 0 && index2 <= lastIndex && index1 !== index2) {
      const index1Prefix = `${name}.${index1}`;
      const index2Prefix = `${name}.${index2}`;
      const fieldStateMap = /* @__PURE__ */ new Map();
      const fieldArrayStateMap = /* @__PURE__ */ new Map();
      const filterName = (value2) => value2.startsWith(`${name}.`) && [
        index1,
        index2
      ].includes(getPathIndex(name, value2));
      const swapIndex = (value2) => value2.startsWith(index1Prefix) ? value2.replace(index1Prefix, index2Prefix) : value2.replace(index2Prefix, index1Prefix);
      getFieldNames(form).filter(filterName).forEach((fieldName) => fieldStateMap.set(fieldName, getFieldState(form, fieldName)));
      fieldStateMap.forEach((fieldState, fieldName) => setFieldState(form, swapIndex(fieldName), fieldState));
      getFieldArrayNames(form).filter(filterName).forEach((fieldArrayName) => fieldArrayStateMap.set(fieldArrayName, getFieldArrayState(form, fieldArrayName)));
      fieldArrayStateMap.forEach((fieldArrayState, fieldArrayName) => setFieldArrayState(form, swapIndex(fieldArrayName), fieldArrayState));
      const itemIndex1 = fieldArray.items[index1];
      fieldArray.items[index1] = fieldArray.items[index2];
      fieldArray.items[index2] = itemIndex1;
      fieldArray.touched = true;
      form.touched = true;
      updateFieldArrayDirty(form, fieldArray);
    }
  }
}
function validateIfRequired(form, fieldOrFieldArray, name, { on: modes, shouldFocus = false }) {
  if (modes.includes((form.internal.validateOn === "submit" ? form.submitted : fieldOrFieldArray.error) ? form.internal.revalidateOn : form.internal.validateOn))
    validate(form, name, {
      shouldFocus
    });
}
async function handleFieldEvent(form, field, name, event, element, validationModes, inputValue) {
  if (inputValue !== void 0)
    field.value = inputValue;
  for (const transformation of field.internal.transform)
    field.value = await transformation(field.value, event, element);
  field.touched = true;
  form.touched = true;
  updateFieldDirty(form, field);
  validateIfRequired(form, field, name, {
    on: validationModes
  });
}
function initializeFieldArrayStore(form, name) {
  if (!getFieldArrayStore(form, name))
    form.internal.fieldArrays[name] = getInitialFieldArrayStore(name);
  return getFieldArrayStore(form, name);
}
function initializeFieldStore(form, name) {
  if (!getFieldStore(form, name))
    form.internal.fields[name] = getInitialFieldStore(name);
  return getFieldStore(form, name);
}
function setErrorResponse(form, formErrors, { duration, shouldActive = true }) {
  const message = Object.entries(formErrors).reduce((errors, [name, error]) => {
    if ([
      getFieldStore(form, name),
      getFieldArrayStore(form, name)
    ].every((fieldOrFieldArray) => !fieldOrFieldArray || shouldActive && !fieldOrFieldArray.active))
      errors.push(error);
    return errors;
  }, []).join(" ");
  if (message)
    setResponse(form, {
      status: "error",
      message
    }, {
      duration
    });
}
function setFieldArrayState(form, name, state) {
  const fieldArray = initializeFieldArrayStore(form, name);
  fieldArray.internal.startItems = state.startItems;
  fieldArray.items = state.items;
  fieldArray.error = state.error;
  fieldArray.touched = state.touched;
  fieldArray.dirty = state.dirty;
}
function setFieldState(form, name, state) {
  const field = initializeFieldStore(form, name);
  field.internal.startValue = state.startValue;
  field.value = state.value;
  field.error = state.error;
  field.touched = state.touched;
  field.dirty = state.dirty;
}
function setFieldArrayValue(form, name, { at: index, value: value2 }) {
  const updateStores = (prevPath, data) => {
    Object.entries(data).forEach(([path, value22]) => {
      const compoundPath = `${prevPath}.${path}`;
      if (form.internal.fieldArrayPaths?.includes(compoundPath.replace(/.\d+./g, ".$."))) {
        const items = value22.map(() => getUniqueId());
        setFieldArrayState(form, compoundPath, {
          startItems: [
            ...items
          ],
          items,
          error: "",
          touched: false,
          dirty: false
        });
      } else if (!value22 || typeof value22 !== "object" || Array.isArray(value22) || value22 instanceof Date || value22 instanceof Blob)
        setFieldState(form, compoundPath, {
          startValue: value22,
          value: value22,
          error: "",
          touched: false,
          dirty: false
        });
      if (value22 && typeof value22 === "object")
        updateStores(compoundPath, value22);
    });
  };
  updateStores(name, {
    [index]: value2
  });
}
function setFieldErrors(form, errors, options) {
  Object.entries(errors).forEach(([name, error]) => {
    if (error)
      setError(form, name, error, {
        ...options,
        shouldFocus: false
      });
  });
}
function sortArrayPathIndex(name) {
  return (pathA, pathB) => getPathIndex(name, pathA) - getPathIndex(name, pathB);
}
function updateFieldArrayDirty(form, fieldArray) {
  const dirty = fieldArray.internal.startItems.join() !== fieldArray.items.join();
  if (dirty !== fieldArray.dirty) {
    fieldArray.dirty = dirty;
    updateFormDirty(form, dirty);
  }
}
function updateFormInvalid(form, invalid) {
  form.invalid = invalid || getFieldAndArrayStores(form).some((fieldOrFieldArray) => fieldOrFieldArray.active && fieldOrFieldArray.error);
}
function updateFormState(form) {
  let touched = false, dirty = false, invalid = false;
  for (const fieldOrFieldArray of getFieldAndArrayStores(form)) {
    if (fieldOrFieldArray.active) {
      if (fieldOrFieldArray.touched)
        touched = true;
      if (fieldOrFieldArray.dirty)
        dirty = true;
      if (fieldOrFieldArray.error)
        invalid = true;
    }
    if (touched && dirty && invalid)
      break;
  }
  form.touched = touched;
  form.dirty = dirty;
  form.invalid = invalid;
}
function formActionQrl(action, arg2) {
  return qwikCity.globalActionQrl(/* @__PURE__ */ qwik.inlinedQrl(async (jsonData, event) => {
    const [action2, arg22] = qwik.useLexicalScope();
    const { validate: validate2, ...formDataInfo } = typeof arg22 === "object" ? arg22 : {
      validate: arg22
    };
    const type = event.request.headers.get("content-type")?.split(/[;,]/, 1)[0];
    const values = type === "application/x-www-form-urlencoded" || type === "multipart/form-data" ? getFormDataValues(await event.request.formData(), formDataInfo) : jsonData;
    const errors = validate2 ? await validate2(values) : {};
    let formActionStore = {
      values,
      errors,
      response: {}
    };
    if (!Object.keys(errors).length)
      try {
        const result = await action2(values, event);
        if (result && typeof result === "object")
          formActionStore = {
            values,
            errors: result.errors || {},
            response: {
              status: result.status,
              message: result.message,
              data: result.data
            }
          };
      } catch (error) {
        if (error instanceof requestHandler.AbortMessage || build.isDev && (error?.constructor?.name === "AbortMessage" || error?.constructor?.name === "RedirectMessage"))
          throw error;
        else {
          console.error(error);
          if (error instanceof FormError)
            formActionStore = {
              values,
              errors: error.errors,
              response: {
                status: "error",
                message: error.message
              }
            };
          else
            formActionStore.response = {
              status: "error",
              message: "An unknown error has occurred."
            };
        }
      }
    return formActionStore;
  }, "formActionQrl_globalActionQrl_VOLgKQUpNuc", [
    action,
    arg2
  ]), {
    id: action.getHash()
  });
}
const formAction$ = qwik.implicit$FirstArg(formActionQrl);
function valiFieldQrl(schema) {
  return /* @__PURE__ */ qwik.inlinedQrl(async (value2) => {
    const [schema2] = qwik.useLexicalScope();
    const resolvedSchema = await schema2.resolve();
    const result = await (typeof resolvedSchema === "function" ? resolvedSchema() : resolvedSchema)._parse(value2, {
      abortPipeEarly: true
    });
    return result.issues?.[0].message || "";
  }, "valiFieldQrl_v0HdjU01a3w", [
    schema
  ]);
}
const valiField$ = qwik.implicit$FirstArg(valiFieldQrl);
function valiFormQrl(schema) {
  return /* @__PURE__ */ qwik.inlinedQrl(async (values) => {
    const [schema2] = qwik.useLexicalScope();
    const resolvedSchema = await schema2.resolve();
    const result = await (typeof resolvedSchema === "function" ? resolvedSchema() : resolvedSchema)._parse(values, {
      abortPipeEarly: true
    });
    return result.issues ? result.issues.reduce((errors, issue) => ({
      ...errors,
      [issue.path.map(({ key }) => key).join(".")]: issue.message
    }), {}) : {};
  }, "valiFormQrl_b4MyjhrwMxE", [
    schema
  ]);
}
const valiForm$ = qwik.implicit$FirstArg(valiFormQrl);
function zodFieldQrl(schema) {
  return /* @__PURE__ */ qwik.inlinedQrl(async (value2) => {
    const [schema2] = qwik.useLexicalScope();
    const result = await getParsedZodSchema(schema2, value2);
    return result.success ? "" : result.error.issues[0].message;
  }, "zodFieldQrl_3o0sC3dcx3Y", [
    schema
  ]);
}
const zodField$ = qwik.implicit$FirstArg(zodFieldQrl);
function zodFormQrl(schema) {
  return /* @__PURE__ */ qwik.inlinedQrl(async (values) => {
    const [schema2] = qwik.useLexicalScope();
    const result = await getParsedZodSchema(schema2, values);
    return result.success ? {} : result.error.issues.reduce((errors, error) => {
      const path = error.path.join(".");
      if (!errors[path])
        errors[path] = error.message;
      return errors;
    }, {});
  }, "zodFormQrl_g3iC2s54jgU", [
    schema
  ]);
}
const zodForm$ = qwik.implicit$FirstArg(zodFormQrl);
const Lifecycle = /* @__PURE__ */ qwik.componentQrl(/* @__PURE__ */ qwik.inlinedQrl((props) => {
  qwik.useVisibleTaskQrl(/* @__PURE__ */ qwik.inlinedQrl(({ cleanup }) => {
    const [props2] = qwik.useLexicalScope();
    props2.store.internal.validate = props2.validate ? Array.isArray(props2.validate) ? props2.validate : [
      props2.validate
    ] : [];
    if ("value" in props2.store)
      props2.store.internal.transform = props2.transform ? Array.isArray(props2.transform) ? props2.transform : [
        props2.transform
      ] : [];
    const consumer = getUniqueId();
    props2.store.internal.consumers.push(consumer);
    if (!props2.store.active) {
      props2.store.active = true;
      updateFormState(props2.of);
    }
    cleanup(() => setTimeout(() => {
      props2.store.internal.consumers.splice(props2.store.internal.consumers.indexOf(consumer), 1);
      if (!props2.keepActive && !props2.store.internal.consumers.length) {
        props2.store.active = false;
        if (!props2.keepState)
          reset(props2.of, props2.store.name);
        else
          updateFormState(props2.of);
      }
      if ("value" in props2.store)
        props2.store.internal.elements = props2.store.internal.elements.filter((element) => element.isConnected);
    }, 15));
  }, "Lifecycle_component_useVisibleTask_LcO2OGTEA00", [
    props
  ]));
  return /* @__PURE__ */ qwik._jsxC(qwik.Slot, null, 3, "Pr_0");
}, "Lifecycle_component_vBVRkPF8kFE"));
function Field({ children, name, type, ...props }) {
  const { of: form } = props;
  const field = getFieldStore(form, name);
  return /* @__PURE__ */ qwik._jsxC(Lifecycle, {
    store: field,
    ...props,
    children: children(field, {
      name,
      autoFocus: build.isServer && !!field.error,
      ref: /* @__PURE__ */ qwik.inlinedQrl((element) => {
        const [field2] = qwik.useLexicalScope();
        field2.internal.elements.push(element);
      }, "Field_Lifecycle_children_0EFsQ07yXsM", [
        field
      ]),
      onInput$: /* @__PURE__ */ qwik.inlinedQrl((event, element) => {
        const [field2, form2, name2, type2] = qwik.useLexicalScope();
        handleFieldEvent(form2, field2, name2, event, element, [
          "touched",
          "input"
        ], getElementInput(element, field2, type2));
      }, "Field_Lifecycle_children_1_WQShqIriXzI", [
        field,
        form,
        name,
        type
      ]),
      onChange$: /* @__PURE__ */ qwik.inlinedQrl((event, element) => {
        const [field2, form2, name2] = qwik.useLexicalScope();
        handleFieldEvent(form2, field2, name2, event, element, [
          "change"
        ]);
      }, "Field_Lifecycle_children_2_vNtVq2dMPhY", [
        field,
        form,
        name
      ]),
      onBlur$: /* @__PURE__ */ qwik.inlinedQrl((event, element) => {
        const [field2, form2, name2] = qwik.useLexicalScope();
        handleFieldEvent(form2, field2, name2, event, element, [
          "touched",
          "blur"
        ]);
      }, "Field_Lifecycle_children_3_fzfym1ErEFI", [
        field,
        form,
        name
      ])
    })
  }, 0, name);
}
function FieldArray({ children, name, ...props }) {
  const fieldArray = getFieldArrayStore(props.of, name);
  return /* @__PURE__ */ qwik._jsxC(Lifecycle, {
    store: fieldArray,
    ...props,
    children: children(fieldArray)
  }, 0, name);
}
function Form({ of: form, action, onSubmit$, responseDuration: duration, keepResponse, shouldActive, shouldTouched, shouldDirty, shouldFocus, reloadDocument, children, ...formProps }) {
  const { encType } = formProps;
  const options = {
    duration,
    shouldActive,
    shouldTouched,
    shouldDirty,
    shouldFocus
  };
  return /* @__PURE__ */ qwik._jsxS("form", {
    ...formProps,
    action: action?.actionPath,
    children,
    onSubmit$: /* @__PURE__ */ qwik.inlinedQrl(async (event, element) => {
      const [action2, encType2, form2, keepResponse2, onSubmit$2, options2, reloadDocument2] = qwik.useLexicalScope();
      if (!keepResponse2)
        form2.response = {};
      form2.submitCount++;
      form2.submitted = true;
      form2.submitting = true;
      try {
        if (await validate(form2, options2)) {
          const values = getValues(form2, options2);
          const [actionResult] = await Promise.all([
            !reloadDocument2 ? action2?.submit(encType2 ? new FormData(element) : values) : void 0,
            // eslint-disable-next-line qwik/valid-lexical-scope
            onSubmit$2?.(values, event)
          ]);
          if (actionResult?.value) {
            const { errors, response } = actionResult.value;
            setFieldErrors(form2, errors, {
              ...options2,
              shouldFocus: false
            });
            if (Object.keys(response).length)
              setResponse(form2, response, options2);
            else
              setErrorResponse(form2, errors, options2);
          }
        }
      } catch (error) {
        if (error instanceof FormError)
          setFieldErrors(form2, error.errors, {
            ...options2,
            shouldFocus: false
          });
        if (!(error instanceof FormError) || error.message)
          setResponse(form2, {
            status: "error",
            message: error?.message || "An unknown error has occurred."
          }, options2);
      } finally {
        form2.submitting = false;
      }
    }, "Form_form_onSubmit_qmKnyqz75p4", [
      action,
      encType,
      form,
      keepResponse,
      onSubmit$,
      options,
      reloadDocument
    ]),
    "preventdefault:submit": !reloadDocument,
    ref: (element) => {
      form.element = element;
    }
  }, {
    method: "post",
    noValidate: true
  }, 0, "Qg_0");
}
function useFormStore({ validate: validate2, validateOn = "submit", revalidateOn = "input", ...options }) {
  return qwik.useStore(() => {
    const [fields, fieldArrays] = getInitialStores(options);
    return {
      internal: {
        fields,
        fieldArrays,
        fieldArrayPaths: options.fieldArrays,
        validate: validate2,
        validators: [],
        validateOn,
        revalidateOn
      },
      // FIXME: Set state based on `action`
      element: void 0,
      submitCount: 0,
      submitting: false,
      submitted: false,
      validating: false,
      touched: false,
      dirty: false,
      invalid: false,
      response: options.action?.value?.response || {}
    };
  });
}
function useForm(options) {
  const form = useFormStore(options);
  return [
    form,
    {
      Form: (props) => Form({
        of: form,
        action: options.action,
        ...props
      }),
      Field: (props) => Field({
        of: form,
        ...props
      }),
      FieldArray: (props) => FieldArray({
        of: form,
        ...props
      })
    }
  ];
}
function toCustomQrl(action, { on: mode }) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2, event, element) => {
    const [action2, mode2] = qwik.useLexicalScope();
    return event.type === mode2 ? action2(value2, event, element) : value2;
  }, "toCustomQrl_4Ad98cQ1Gyc", [
    action,
    mode
  ]);
}
const toCustom$ = qwik.implicit$FirstArg(toCustomQrl);
function toLowerCase(options) {
  return toCustomQrl(/* @__PURE__ */ qwik.inlinedQrl((value2) => value2 && value2.toLowerCase(), "toLowerCase_toCustom_DqH9OzaMLmQ"), options);
}
function toTrimmed(options) {
  return toCustomQrl(/* @__PURE__ */ qwik.inlinedQrl((value2) => value2 && value2.trim(), "toTrimmed_toCustom_eTBCNsyXS74"), options);
}
function toUpperCase(options) {
  return toCustomQrl(/* @__PURE__ */ qwik.inlinedQrl((value2) => value2 && value2.toUpperCase(), "toUpperCase_toCustom_jn0vB1n0Eyw"), options);
}
function customQrl(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl(async (value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return (Array.isArray(value2) ? value2.length : value2 || value2 === 0) && !await requirement2(value2) ? error2 : "";
  }, "customQrl_xXv2fc1rQKg", [
    error,
    requirement
  ]);
}
const custom$ = qwik.implicit$FirstArg(customQrl);
function email(error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2] = qwik.useLexicalScope();
    return value2 && !/^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@(([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{2,})$/i.test(value2) ? error2 : "";
  }, "email_WNtBdMWIifo", [
    error
  ]);
}
function maxLength(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2?.length && value2.length > requirement2 ? error2 : "";
  }, "maxLength_0ReltMI3w50", [
    error,
    requirement
  ]);
}
function maxRange(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return (value2 || value2 === 0) && value2 > requirement2 ? error2 : "";
  }, "maxRange_392rGvSQR4s", [
    error,
    requirement
  ]);
}
function maxSize(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2 && (Array.isArray(value2) ? [
      ...value2
    ].some((file) => file.size > requirement2) : value2.size > requirement2) ? error2 : "";
  }, "maxSize_hkWBlzJSItY", [
    error,
    requirement
  ]);
}
function maxTotalSize(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2?.length && [
      ...value2
    ].reduce((size, file) => size + file.size, 0) > requirement2 ? error2 : "";
  }, "maxTotalSize_T2TywIsANA0", [
    error,
    requirement
  ]);
}
function mimeType(requirement, error) {
  const mimeTypes = Array.isArray(requirement) ? requirement : [
    requirement
  ];
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, mimeTypes2] = qwik.useLexicalScope();
    return value2 && (Array.isArray(value2) ? [
      ...value2
    ].some((file) => !mimeTypes2.includes(file.type)) : !mimeTypes2.includes(value2.type)) ? error2 : "";
  }, "mimeType_G7xnuJT7jNA", [
    error,
    mimeTypes
  ]);
}
function minLength(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2?.length && value2.length < requirement2 ? error2 : "";
  }, "minLength_8vMT3TABZIQ", [
    error,
    requirement
  ]);
}
function minRange(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return (value2 || value2 === 0) && value2 < requirement2 ? error2 : "";
  }, "minRange_aEbSHik7hw4", [
    error,
    requirement
  ]);
}
function minSize(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2 && (Array.isArray(value2) ? [
      ...value2
    ].some((file) => file.size < requirement2) : value2.size < requirement2) ? error2 : "";
  }, "minSize_BGwYN0TDDJg", [
    error,
    requirement
  ]);
}
function minTotalSize(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2?.length && [
      ...value2
    ].reduce((size, file) => size + file.size, 0) < requirement2 ? error2 : "";
  }, "minTotalSize_jNOd7uwD1Mc", [
    error,
    requirement
  ]);
}
function pattern(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return value2 && !requirement2.test(value2) ? error2 : "";
  }, "pattern_s760ZT1A33E", [
    error,
    requirement
  ]);
}
function required(error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2] = qwik.useLexicalScope();
    return !value2 && value2 !== 0 || Array.isArray(value2) && !value2.length ? error2 : "";
  }, "required_TD2dR9TvPOM", [
    error
  ]);
}
function url(error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2] = qwik.useLexicalScope();
    try {
      value2 && new URL(value2);
      return "";
    } catch (_) {
      return error2;
    }
  }, "url_QhQuK0HY6ZA", [
    error
  ]);
}
function value(requirement, error) {
  return /* @__PURE__ */ qwik.inlinedQrl((value2) => {
    const [error2, requirement2] = qwik.useLexicalScope();
    return (value2 || value2 === 0) && value2 !== requirement2 ? error2 : "";
  }, "value_UT966TDw31E", [
    error,
    requirement
  ]);
}
exports.Field = Field;
exports.FieldArray = FieldArray;
exports.Form = Form;
exports.FormError = FormError;
exports.clearError = clearError;
exports.clearResponse = clearResponse;
exports.custom$ = custom$;
exports.customQrl = customQrl;
exports.email = email;
exports.focus = focus;
exports.formAction$ = formAction$;
exports.formActionQrl = formActionQrl;
exports.getError = getError;
exports.getErrors = getErrors;
exports.getValue = getValue;
exports.getValues = getValues;
exports.hasField = hasField;
exports.hasFieldArray = hasFieldArray;
exports.insert = insert;
exports.maxLength = maxLength;
exports.maxRange = maxRange;
exports.maxSize = maxSize;
exports.maxTotalSize = maxTotalSize;
exports.mimeType = mimeType;
exports.minLength = minLength;
exports.minRange = minRange;
exports.minSize = minSize;
exports.minTotalSize = minTotalSize;
exports.move = move;
exports.pattern = pattern;
exports.remove = remove;
exports.replace = replace;
exports.required = required;
exports.reset = reset;
exports.setError = setError;
exports.setResponse = setResponse;
exports.setValue = setValue;
exports.setValues = setValues;
exports.submit = submit;
exports.swap = swap;
exports.toCustom$ = toCustom$;
exports.toCustomQrl = toCustomQrl;
exports.toLowerCase = toLowerCase;
exports.toTrimmed = toTrimmed;
exports.toUpperCase = toUpperCase;
exports.url = url;
exports.useForm = useForm;
exports.useFormStore = useFormStore;
exports.valiField$ = valiField$;
exports.valiFieldQrl = valiFieldQrl;
exports.valiForm$ = valiForm$;
exports.valiFormQrl = valiFormQrl;
exports.validate = validate;
exports.value = value;
exports.zodField$ = zodField$;
exports.zodFieldQrl = zodFieldQrl;
exports.zodForm$ = zodForm$;
exports.zodFormQrl = zodFormQrl;
