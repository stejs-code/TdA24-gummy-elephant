import {
  __commonJS,
  __toESM
} from "./chunk-TCQZMY3T.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/cross-fetch/dist/browser-polyfill.js
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response2(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response2(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response2;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(typeof self !== "undefined" ? self : exports);
  }
});

// node_modules/meilisearch/dist/bundles/meilisearch.esm.js
var import_crypto = __toESM(require_crypto());
var MatchingStrategies = {
  ALL: "all",
  LAST: "last"
};
var ContentTypeEnum = {
  JSON: "application/json",
  CSV: "text/csv",
  NDJSON: "application/x-ndjson"
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var MeiliSearchCommunicationError = class _MeiliSearchCommunicationError extends Error {
  constructor(message, body, url, stack) {
    var _a, _b, _c;
    super(message);
    Object.setPrototypeOf(this, _MeiliSearchCommunicationError.prototype);
    this.name = "MeiliSearchCommunicationError";
    if (body instanceof Response) {
      this.message = body.statusText;
      this.statusCode = body.status;
    }
    if (body instanceof Error) {
      this.errno = body.errno;
      this.code = body.code;
    }
    if (stack) {
      this.stack = stack;
      this.stack = (_a = this.stack) === null || _a === void 0 ? void 0 : _a.replace(/(TypeError|FetchError)/, this.name);
      this.stack = (_b = this.stack) === null || _b === void 0 ? void 0 : _b.replace("Failed to fetch", `request to ${url} failed, reason: connect ECONNREFUSED`);
      this.stack = (_c = this.stack) === null || _c === void 0 ? void 0 : _c.replace("Not Found", `Not Found: ${url}`);
    } else {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, _MeiliSearchCommunicationError);
      }
    }
  }
};
var MeiliSearchApiError = class extends Error {
  constructor(error, status) {
    super(error.message);
    Object.setPrototypeOf(this, MeiliSearchApiError.prototype);
    this.name = "MeiliSearchApiError";
    this.code = error.code;
    this.type = error.type;
    this.link = error.link;
    this.message = error.message;
    this.httpStatus = status;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, MeiliSearchApiError);
    }
  }
};
function httpResponseErrorHandler(response) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!response.ok) {
      let responseBody;
      try {
        responseBody = yield response.json();
      } catch (e) {
        throw new MeiliSearchCommunicationError(response.statusText, response, response.url);
      }
      throw new MeiliSearchApiError(responseBody, response.status);
    }
    return response;
  });
}
function httpErrorHandler(response, stack, url) {
  if (response.name !== "MeiliSearchApiError") {
    throw new MeiliSearchCommunicationError(response.message, response, url, stack);
  }
  throw response;
}
var MeiliSearchError = class _MeiliSearchError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _MeiliSearchError.prototype);
    this.name = "MeiliSearchError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _MeiliSearchError);
    }
  }
};
var MeiliSearchTimeOutError = class _MeiliSearchTimeOutError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _MeiliSearchTimeOutError.prototype);
    this.name = "MeiliSearchTimeOutError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _MeiliSearchTimeOutError);
    }
  }
};
function versionErrorHintMessage(message, method) {
  return `${message}
Hint: It might not be working because maybe you're not up to date with the Meilisearch version that ${method} call requires.`;
}
function removeUndefinedFromObject(obj) {
  return Object.entries(obj).reduce((acc, curEntry) => {
    const [key, val] = curEntry;
    if (val !== void 0)
      acc[key] = val;
    return acc;
  }, {});
}
function sleep(ms) {
  return __awaiter(this, void 0, void 0, function* () {
    return yield new Promise((resolve) => setTimeout(resolve, ms));
  });
}
function addProtocolIfNotPresent(host) {
  if (!(host.startsWith("https://") || host.startsWith("http://"))) {
    return `http://${host}`;
  }
  return host;
}
function addTrailingSlash(url) {
  if (!url.endsWith("/")) {
    url += "/";
  }
  return url;
}
function validateUuid4(uuid) {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(uuid);
}
var PACKAGE_VERSION = "0.35.0";
function toQueryParams(parameters) {
  const params = Object.keys(parameters);
  const queryParams = params.reduce((acc, key) => {
    const value = parameters[key];
    if (value === void 0) {
      return acc;
    } else if (Array.isArray(value)) {
      return Object.assign(Object.assign({}, acc), { [key]: value.join(",") });
    } else if (value instanceof Date) {
      return Object.assign(Object.assign({}, acc), { [key]: value.toISOString() });
    }
    return Object.assign(Object.assign({}, acc), { [key]: value });
  }, {});
  return queryParams;
}
function constructHostURL(host) {
  try {
    host = addProtocolIfNotPresent(host);
    host = addTrailingSlash(host);
    return host;
  } catch (e) {
    throw new MeiliSearchError("The provided host is not valid.");
  }
}
function cloneAndParseHeaders(headers) {
  if (Array.isArray(headers)) {
    return headers.reduce((acc, headerPair) => {
      acc[headerPair[0]] = headerPair[1];
      return acc;
    }, {});
  } else if ("has" in headers) {
    const clonedHeaders = {};
    headers.forEach((value, key) => clonedHeaders[key] = value);
    return clonedHeaders;
  } else {
    return Object.assign({}, headers);
  }
}
function createHeaders(config) {
  var _a, _b;
  const agentHeader = "X-Meilisearch-Client";
  const packageAgent = `Meilisearch JavaScript (v${PACKAGE_VERSION})`;
  const contentType = "Content-Type";
  const authorization = "Authorization";
  const headers = cloneAndParseHeaders((_b = (_a = config.requestConfig) === null || _a === void 0 ? void 0 : _a.headers) !== null && _b !== void 0 ? _b : {});
  if (config.apiKey && !headers[authorization]) {
    headers[authorization] = `Bearer ${config.apiKey}`;
  }
  if (!headers[contentType]) {
    headers["Content-Type"] = "application/json";
  }
  if (config.clientAgents && Array.isArray(config.clientAgents)) {
    const clients = config.clientAgents.concat(packageAgent);
    headers[agentHeader] = clients.join(" ; ");
  } else if (config.clientAgents && !Array.isArray(config.clientAgents)) {
    throw new MeiliSearchError(`Meilisearch: The header "${agentHeader}" should be an array of string(s).
`);
  } else {
    headers[agentHeader] = packageAgent;
  }
  return headers;
}
var HttpRequests = class {
  constructor(config) {
    this.headers = createHeaders(config);
    this.requestConfig = config.requestConfig;
    this.httpClient = config.httpClient;
    try {
      const host = constructHostURL(config.host);
      this.url = new URL(host);
    } catch (e) {
      throw new MeiliSearchError("The provided host is not valid.");
    }
  }
  request({ method, url, params, body, config = {} }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof fetch === "undefined") {
        require_browser_polyfill();
      }
      const constructURL = new URL(url, this.url);
      if (params) {
        const queryParams = new URLSearchParams();
        Object.keys(params).filter((x) => params[x] !== null).map((x) => queryParams.set(x, params[x]));
        constructURL.search = queryParams.toString();
      }
      if (!((_a = config.headers) === null || _a === void 0 ? void 0 : _a["Content-Type"])) {
        body = JSON.stringify(body);
      }
      const headers = Object.assign(Object.assign({}, this.headers), config.headers);
      try {
        const fetchFn = this.httpClient ? this.httpClient : fetch;
        const result = fetchFn(constructURL.toString(), Object.assign(Object.assign(Object.assign({}, config), this.requestConfig), {
          method,
          body,
          headers
        }));
        if (this.httpClient) {
          return yield result;
        }
        const response = yield result.then((res) => httpResponseErrorHandler(res));
        const parsedBody = yield response.json().catch(() => void 0);
        return parsedBody;
      } catch (e) {
        const stack = e.stack;
        httpErrorHandler(e, stack, constructURL.toString());
      }
    });
  }
  get(url, params, config) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.request({
        method: "GET",
        url,
        params,
        config
      });
    });
  }
  post(url, data, params, config) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.request({
        method: "POST",
        url,
        body: data,
        params,
        config
      });
    });
  }
  put(url, data, params, config) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.request({
        method: "PUT",
        url,
        body: data,
        params,
        config
      });
    });
  }
  patch(url, data, params, config) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.request({
        method: "PATCH",
        url,
        body: data,
        params,
        config
      });
    });
  }
  delete(url, data, params, config) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.request({
        method: "DELETE",
        url,
        body: data,
        params,
        config
      });
    });
  }
};
var EnqueuedTask = class {
  constructor(task) {
    this.taskUid = task.taskUid;
    this.indexUid = task.indexUid;
    this.status = task.status;
    this.type = task.type;
    this.enqueuedAt = new Date(task.enqueuedAt);
  }
};
var Task = class {
  constructor(task) {
    this.indexUid = task.indexUid;
    this.status = task.status;
    this.type = task.type;
    this.uid = task.uid;
    this.details = task.details;
    this.canceledBy = task.canceledBy;
    this.error = task.error;
    this.duration = task.duration;
    this.startedAt = new Date(task.startedAt);
    this.enqueuedAt = new Date(task.enqueuedAt);
    this.finishedAt = new Date(task.finishedAt);
  }
};
var TaskClient = class {
  constructor(config) {
    this.httpRequest = new HttpRequests(config);
  }
  /**
   * Get one task
   *
   * @param uid - Unique identifier of the task
   * @returns
   */
  getTask(uid) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `tasks/${uid}`;
      const taskItem = yield this.httpRequest.get(url);
      return new Task(taskItem);
    });
  }
  /**
   * Get tasks
   *
   * @param parameters - Parameters to browse the tasks
   * @returns Promise containing all tasks
   */
  getTasks(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `tasks`;
      const tasks = yield this.httpRequest.get(url, toQueryParams(parameters));
      return Object.assign(Object.assign({}, tasks), { results: tasks.results.map((task) => new Task(task)) });
    });
  }
  /**
   * Wait for a task to be processed.
   *
   * @param taskUid - Task identifier
   * @param options - Additional configuration options
   * @returns Promise returning a task after it has been processed
   */
  waitForTask(taskUid, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const startingTime = Date.now();
      while (Date.now() - startingTime < timeOutMs) {
        const response = yield this.getTask(taskUid);
        if (![
          "enqueued",
          "processing"
          /* TaskStatus.TASK_PROCESSING */
        ].includes(response.status))
          return response;
        yield sleep(intervalMs);
      }
      throw new MeiliSearchTimeOutError(`timeout of ${timeOutMs}ms has exceeded on process ${taskUid} when waiting a task to be resolved.`);
    });
  }
  /**
   * Waits for multiple tasks to be processed
   *
   * @param taskUids - Tasks identifier list
   * @param options - Wait options
   * @returns Promise returning a list of tasks after they have been processed
   */
  waitForTasks(taskUids, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const tasks = [];
      for (const taskUid of taskUids) {
        const task = yield this.waitForTask(taskUid, {
          timeOutMs,
          intervalMs
        });
        tasks.push(task);
      }
      return tasks;
    });
  }
  /**
   * Cancel a list of enqueued or processing tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  cancelTasks(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `tasks/cancel`;
      const task = yield this.httpRequest.post(url, {}, toQueryParams(parameters));
      return new EnqueuedTask(task);
    });
  }
  /**
   * Delete a list tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  deleteTasks(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `tasks`;
      const task = yield this.httpRequest.delete(url, {}, toQueryParams(parameters));
      return new EnqueuedTask(task);
    });
  }
};
var Index = class {
  /**
   * @param config - Request configuration options
   * @param uid - UID of the index
   * @param primaryKey - Primary Key of the index
   */
  constructor(config, uid, primaryKey) {
    this.uid = uid;
    this.primaryKey = primaryKey;
    this.httpRequest = new HttpRequests(config);
    this.tasks = new TaskClient(config);
  }
  ///
  /// SEARCH
  ///
  /**
   * Search for documents into an index
   *
   * @param query - Query string
   * @param options - Search options
   * @param config - Additional request configuration options
   * @returns Promise containing the search response
   */
  search(query, options, config) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/search`;
      return yield this.httpRequest.post(url, removeUndefinedFromObject(Object.assign({ q: query }, options)), void 0, config);
    });
  }
  /**
   * Search for documents into an index using the GET method
   *
   * @param query - Query string
   * @param options - Search options
   * @param config - Additional request configuration options
   * @returns Promise containing the search response
   */
  searchGet(query, options, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/search`;
      const parseFilter = (filter) => {
        if (typeof filter === "string")
          return filter;
        else if (Array.isArray(filter))
          throw new MeiliSearchError("The filter query parameter should be in string format when using searchGet");
        else
          return void 0;
      };
      const getParams = Object.assign(Object.assign({ q: query }, options), { filter: parseFilter(options === null || options === void 0 ? void 0 : options.filter), sort: (_a = options === null || options === void 0 ? void 0 : options.sort) === null || _a === void 0 ? void 0 : _a.join(","), facets: (_b = options === null || options === void 0 ? void 0 : options.facets) === null || _b === void 0 ? void 0 : _b.join(","), attributesToRetrieve: (_c = options === null || options === void 0 ? void 0 : options.attributesToRetrieve) === null || _c === void 0 ? void 0 : _c.join(","), attributesToCrop: (_d = options === null || options === void 0 ? void 0 : options.attributesToCrop) === null || _d === void 0 ? void 0 : _d.join(","), attributesToHighlight: (_e = options === null || options === void 0 ? void 0 : options.attributesToHighlight) === null || _e === void 0 ? void 0 : _e.join(","), vector: (_f = options === null || options === void 0 ? void 0 : options.vector) === null || _f === void 0 ? void 0 : _f.join(","), attributesToSearchOn: (_g = options === null || options === void 0 ? void 0 : options.attributesToSearchOn) === null || _g === void 0 ? void 0 : _g.join(",") });
      return yield this.httpRequest.get(url, removeUndefinedFromObject(getParams), config);
    });
  }
  /**
   * Search for facet values
   *
   * @param params - Parameters used to search on the facets
   * @param config - Additional request configuration options
   * @returns Promise containing the search response
   */
  searchForFacetValues(params, config) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/facet-search`;
      return yield this.httpRequest.post(url, removeUndefinedFromObject(params), void 0, config);
    });
  }
  ///
  /// INDEX
  ///
  /**
   * Get index information.
   *
   * @returns Promise containing index information
   */
  getRawInfo() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}`;
      const res = yield this.httpRequest.get(url);
      this.primaryKey = res.primaryKey;
      this.updatedAt = new Date(res.updatedAt);
      this.createdAt = new Date(res.createdAt);
      return res;
    });
  }
  /**
   * Fetch and update Index information.
   *
   * @returns Promise to the current Index object with updated information
   */
  fetchInfo() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getRawInfo();
      return this;
    });
  }
  /**
   * Get Primary Key.
   *
   * @returns Promise containing the Primary Key of the index
   */
  fetchPrimaryKey() {
    return __awaiter(this, void 0, void 0, function* () {
      this.primaryKey = (yield this.getRawInfo()).primaryKey;
      return this.primaryKey;
    });
  }
  /**
   * Create an index.
   *
   * @param uid - Unique identifier of the Index
   * @param options - Index options
   * @param config - Request configuration options
   * @returns Newly created Index object
   */
  static create(uid, options = {}, config) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes`;
      const req = new HttpRequests(config);
      const task = yield req.post(url, Object.assign(Object.assign({}, options), { uid }));
      return new EnqueuedTask(task);
    });
  }
  /**
   * Update an index.
   *
   * @param data - Data to update
   * @returns Promise to the current Index object with updated information
   */
  update(data) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}`;
      const task = yield this.httpRequest.patch(url, data);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  /**
   * Delete an index.
   *
   * @returns Promise which resolves when index is deleted successfully
   */
  delete() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}`;
      const task = yield this.httpRequest.delete(url);
      return new EnqueuedTask(task);
    });
  }
  ///
  /// TASKS
  ///
  /**
   * Get the list of all the tasks of the index.
   *
   * @param parameters - Parameters to browse the tasks
   * @returns Promise containing all tasks
   */
  getTasks(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.getTasks(Object.assign(Object.assign({}, parameters), { indexUids: [this.uid] }));
    });
  }
  /**
   * Get one task of the index.
   *
   * @param taskUid - Task identifier
   * @returns Promise containing a task
   */
  getTask(taskUid) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.getTask(taskUid);
    });
  }
  /**
   * Wait for multiple tasks to be processed.
   *
   * @param taskUids - Tasks identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise containing an array of tasks
   */
  waitForTasks(taskUids, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.waitForTasks(taskUids, {
        timeOutMs,
        intervalMs
      });
    });
  }
  /**
   * Wait for a task to be processed.
   *
   * @param taskUid - Task identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise containing an array of tasks
   */
  waitForTask(taskUid, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.waitForTask(taskUid, {
        timeOutMs,
        intervalMs
      });
    });
  }
  ///
  /// STATS
  ///
  /**
   * Get stats of an index
   *
   * @returns Promise containing object with stats of the index
   */
  getStats() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/stats`;
      return yield this.httpRequest.get(url);
    });
  }
  ///
  /// DOCUMENTS
  ///
  /**
   * Get documents of an index.
   *
   * @param parameters - Parameters to browse the documents. Parameters can
   *   contain the `filter` field only available in Meilisearch v1.2 and newer
   * @returns Promise containing the returned documents
   */
  getDocuments(parameters = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      parameters = removeUndefinedFromObject(parameters);
      if (parameters.filter !== void 0) {
        try {
          const url = `indexes/${this.uid}/documents/fetch`;
          return yield this.httpRequest.post(url, parameters);
        } catch (e) {
          if (e instanceof MeiliSearchCommunicationError) {
            e.message = versionErrorHintMessage(e.message, "getDocuments");
          } else if (e instanceof MeiliSearchApiError) {
            e.message = versionErrorHintMessage(e.message, "getDocuments");
          }
          throw e;
        }
      } else {
        const url = `indexes/${this.uid}/documents`;
        const fields = Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields) ? { fields: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(",") } : {};
        return yield this.httpRequest.get(url, Object.assign(Object.assign({}, parameters), fields));
      }
    });
  }
  /**
   * Get one document
   *
   * @param documentId - Document ID
   * @param parameters - Parameters applied on a document
   * @returns Promise containing Document response
   */
  getDocument(documentId, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents/${documentId}`;
      const fields = (() => {
        var _a;
        if (Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields)) {
          return (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(",");
        }
        return void 0;
      })();
      return yield this.httpRequest.get(url, removeUndefinedFromObject(Object.assign(Object.assign({}, parameters), { fields })));
    });
  }
  /**
   * Add or replace multiples documents to an index
   *
   * @param documents - Array of Document objects to add/replace
   * @param options - Options on document addition
   * @returns Promise containing an EnqueuedTask
   */
  addDocuments(documents, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents`;
      const task = yield this.httpRequest.post(url, documents, options);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Add or replace multiples documents in a string format to an index. It only
   * supports csv, ndjson and json formats.
   *
   * @param documents - Documents provided in a string to add/replace
   * @param contentType - Content type of your document:
   *   'text/csv'|'application/x-ndjson'|'application/json'
   * @param options - Options on document addition
   * @returns Promise containing an EnqueuedTask
   */
  addDocumentsFromString(documents, contentType, queryParams) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents`;
      const task = yield this.httpRequest.post(url, documents, queryParams, {
        headers: {
          "Content-Type": contentType
        }
      });
      return new EnqueuedTask(task);
    });
  }
  /**
   * Add or replace multiples documents to an index in batches
   *
   * @param documents - Array of Document objects to add/replace
   * @param batchSize - Size of the batch
   * @param options - Options on document addition
   * @returns Promise containing array of enqueued task objects for each batch
   */
  addDocumentsInBatches(documents, batchSize = 1e3, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const updates = [];
      for (let i = 0; i < documents.length; i += batchSize) {
        updates.push(yield this.addDocuments(documents.slice(i, i + batchSize), options));
      }
      return updates;
    });
  }
  /**
   * Add or update multiples documents to an index
   *
   * @param documents - Array of Document objects to add/update
   * @param options - Options on document update
   * @returns Promise containing an EnqueuedTask
   */
  updateDocuments(documents, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents`;
      const task = yield this.httpRequest.put(url, documents, options);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Add or update multiples documents to an index in batches
   *
   * @param documents - Array of Document objects to add/update
   * @param batchSize - Size of the batch
   * @param options - Options on document update
   * @returns Promise containing array of enqueued task objects for each batch
   */
  updateDocumentsInBatches(documents, batchSize = 1e3, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const updates = [];
      for (let i = 0; i < documents.length; i += batchSize) {
        updates.push(yield this.updateDocuments(documents.slice(i, i + batchSize), options));
      }
      return updates;
    });
  }
  /**
   * Add or update multiples documents in a string format to an index. It only
   * supports csv, ndjson and json formats.
   *
   * @param documents - Documents provided in a string to add/update
   * @param contentType - Content type of your document:
   *   'text/csv'|'application/x-ndjson'|'application/json'
   * @param queryParams - Options on raw document addition
   * @returns Promise containing an EnqueuedTask
   */
  updateDocumentsFromString(documents, contentType, queryParams) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents`;
      const task = yield this.httpRequest.put(url, documents, queryParams, {
        headers: {
          "Content-Type": contentType
        }
      });
      return new EnqueuedTask(task);
    });
  }
  /**
   * Delete one document
   *
   * @param documentId - Id of Document to delete
   * @returns Promise containing an EnqueuedTask
   */
  deleteDocument(documentId) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents/${documentId}`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  /**
   * Delete multiples documents of an index.
   *
   * @param params - Params value can be:
   *
   *   - DocumentsDeletionQuery: An object containing the parameters to customize
   *       your document deletion. Only available in Meilisearch v1.2 and newer
   *   - DocumentsIds: An array of document ids to delete
   *
   * @returns Promise containing an EnqueuedTask
   */
  deleteDocuments(params) {
    return __awaiter(this, void 0, void 0, function* () {
      const isDocumentsDeletionQuery = !Array.isArray(params) && typeof params === "object";
      const endpoint = isDocumentsDeletionQuery ? "documents/delete" : "documents/delete-batch";
      const url = `indexes/${this.uid}/${endpoint}`;
      try {
        const task = yield this.httpRequest.post(url, params);
        return new EnqueuedTask(task);
      } catch (e) {
        if (e instanceof MeiliSearchCommunicationError && isDocumentsDeletionQuery) {
          e.message = versionErrorHintMessage(e.message, "deleteDocuments");
        } else if (e instanceof MeiliSearchApiError) {
          e.message = versionErrorHintMessage(e.message, "deleteDocuments");
        }
        throw e;
      }
    });
  }
  /**
   * Delete all documents of an index
   *
   * @returns Promise containing an EnqueuedTask
   */
  deleteAllDocuments() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/documents`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// SETTINGS
  ///
  /**
   * Retrieve all settings
   *
   * @returns Promise containing Settings object
   */
  getSettings() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update all settings Any parameters not provided will be left unchanged.
   *
   * @param settings - Object containing parameters with their updated values
   * @returns Promise containing an EnqueuedTask
   */
  updateSettings(settings) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings`;
      const task = yield this.httpRequest.patch(url, settings);
      task.enqueued = new Date(task.enqueuedAt);
      return task;
    });
  }
  /**
   * Reset settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetSettings() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// PAGINATION SETTINGS
  ///
  /**
   * Get the pagination settings.
   *
   * @returns Promise containing object of pagination settings
   */
  getPagination() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/pagination`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the pagination settings.
   *
   * @param pagination - Pagination object
   * @returns Promise containing an EnqueuedTask
   */
  updatePagination(pagination) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/pagination`;
      const task = yield this.httpRequest.patch(url, pagination);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the pagination settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetPagination() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/pagination`;
      const task = yield this.httpRequest.delete(url);
      return new EnqueuedTask(task);
    });
  }
  ///
  /// SYNONYMS
  ///
  /**
   * Get the list of all synonyms
   *
   * @returns Promise containing object of synonym mappings
   */
  getSynonyms() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/synonyms`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the list of synonyms. Overwrite the old list.
   *
   * @param synonyms - Mapping of synonyms with their associated words
   * @returns Promise containing an EnqueuedTask
   */
  updateSynonyms(synonyms) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/synonyms`;
      const task = yield this.httpRequest.put(url, synonyms);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the synonym list to be empty again
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetSynonyms() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/synonyms`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// STOP WORDS
  ///
  /**
   * Get the list of all stop-words
   *
   * @returns Promise containing array of stop-words
   */
  getStopWords() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/stop-words`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the list of stop-words. Overwrite the old list.
   *
   * @param stopWords - Array of strings that contains the stop-words.
   * @returns Promise containing an EnqueuedTask
   */
  updateStopWords(stopWords) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/stop-words`;
      const task = yield this.httpRequest.put(url, stopWords);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the stop-words list to be empty again
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetStopWords() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/stop-words`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// RANKING RULES
  ///
  /**
   * Get the list of all ranking-rules
   *
   * @returns Promise containing array of ranking-rules
   */
  getRankingRules() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/ranking-rules`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the list of ranking-rules. Overwrite the old list.
   *
   * @param rankingRules - Array that contain ranking rules sorted by order of
   *   importance.
   * @returns Promise containing an EnqueuedTask
   */
  updateRankingRules(rankingRules) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/ranking-rules`;
      const task = yield this.httpRequest.put(url, rankingRules);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the ranking rules list to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetRankingRules() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/ranking-rules`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// DISTINCT ATTRIBUTE
  ///
  /**
   * Get the distinct-attribute
   *
   * @returns Promise containing the distinct-attribute of the index
   */
  getDistinctAttribute() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/distinct-attribute`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the distinct-attribute.
   *
   * @param distinctAttribute - Field name of the distinct-attribute
   * @returns Promise containing an EnqueuedTask
   */
  updateDistinctAttribute(distinctAttribute) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/distinct-attribute`;
      const task = yield this.httpRequest.put(url, distinctAttribute);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the distinct-attribute.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetDistinctAttribute() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/distinct-attribute`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// FILTERABLE ATTRIBUTES
  ///
  /**
   * Get the filterable-attributes
   *
   * @returns Promise containing an array of filterable-attributes
   */
  getFilterableAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/filterable-attributes`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the filterable-attributes.
   *
   * @param filterableAttributes - Array of strings containing the attributes
   *   that can be used as filters at query time
   * @returns Promise containing an EnqueuedTask
   */
  updateFilterableAttributes(filterableAttributes) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/filterable-attributes`;
      const task = yield this.httpRequest.put(url, filterableAttributes);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the filterable-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetFilterableAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/filterable-attributes`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// SORTABLE ATTRIBUTES
  ///
  /**
   * Get the sortable-attributes
   *
   * @returns Promise containing array of sortable-attributes
   */
  getSortableAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/sortable-attributes`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the sortable-attributes.
   *
   * @param sortableAttributes - Array of strings containing the attributes that
   *   can be used to sort search results at query time
   * @returns Promise containing an EnqueuedTask
   */
  updateSortableAttributes(sortableAttributes) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/sortable-attributes`;
      const task = yield this.httpRequest.put(url, sortableAttributes);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the sortable-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetSortableAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/sortable-attributes`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// SEARCHABLE ATTRIBUTE
  ///
  /**
   * Get the searchable-attributes
   *
   * @returns Promise containing array of searchable-attributes
   */
  getSearchableAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/searchable-attributes`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the searchable-attributes.
   *
   * @param searchableAttributes - Array of strings that contains searchable
   *   attributes sorted by order of importance(most to least important)
   * @returns Promise containing an EnqueuedTask
   */
  updateSearchableAttributes(searchableAttributes) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/searchable-attributes`;
      const task = yield this.httpRequest.put(url, searchableAttributes);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the searchable-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetSearchableAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/searchable-attributes`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// DISPLAYED ATTRIBUTE
  ///
  /**
   * Get the displayed-attributes
   *
   * @returns Promise containing array of displayed-attributes
   */
  getDisplayedAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/displayed-attributes`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the displayed-attributes.
   *
   * @param displayedAttributes - Array of strings that contains attributes of
   *   an index to display
   * @returns Promise containing an EnqueuedTask
   */
  updateDisplayedAttributes(displayedAttributes) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/displayed-attributes`;
      const task = yield this.httpRequest.put(url, displayedAttributes);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the displayed-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetDisplayedAttributes() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/displayed-attributes`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// TYPO TOLERANCE
  ///
  /**
   * Get the typo tolerance settings.
   *
   * @returns Promise containing the typo tolerance settings.
   */
  getTypoTolerance() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/typo-tolerance`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the typo tolerance settings.
   *
   * @param typoTolerance - Object containing the custom typo tolerance
   *   settings.
   * @returns Promise containing object of the enqueued update
   */
  updateTypoTolerance(typoTolerance) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/typo-tolerance`;
      const task = yield this.httpRequest.patch(url, typoTolerance);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  /**
   * Reset the typo tolerance settings.
   *
   * @returns Promise containing object of the enqueued update
   */
  resetTypoTolerance() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/typo-tolerance`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// FACETING
  ///
  /**
   * Get the faceting settings.
   *
   * @returns Promise containing object of faceting index settings
   */
  getFaceting() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/faceting`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the faceting settings.
   *
   * @param faceting - Faceting index settings object
   * @returns Promise containing an EnqueuedTask
   */
  updateFaceting(faceting) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/faceting`;
      const task = yield this.httpRequest.patch(url, faceting);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the faceting settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetFaceting() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/faceting`;
      const task = yield this.httpRequest.delete(url);
      return new EnqueuedTask(task);
    });
  }
  ///
  /// SEPARATOR TOKENS
  ///
  /**
   * Get the list of all separator tokens.
   *
   * @returns Promise containing array of separator tokens
   */
  getSeparatorTokens() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/separator-tokens`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the list of separator tokens. Overwrite the old list.
   *
   * @param separatorTokens - Array that contains separator tokens.
   * @returns Promise containing an EnqueuedTask or null
   */
  updateSeparatorTokens(separatorTokens) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/separator-tokens`;
      const task = yield this.httpRequest.put(url, separatorTokens);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the separator tokens list to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetSeparatorTokens() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/separator-tokens`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// NON-SEPARATOR TOKENS
  ///
  /**
   * Get the list of all non-separator tokens.
   *
   * @returns Promise containing array of non-separator tokens
   */
  getNonSeparatorTokens() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/non-separator-tokens`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the list of non-separator tokens. Overwrite the old list.
   *
   * @param nonSeparatorTokens - Array that contains non-separator tokens.
   * @returns Promise containing an EnqueuedTask or null
   */
  updateNonSeparatorTokens(nonSeparatorTokens) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/non-separator-tokens`;
      const task = yield this.httpRequest.put(url, nonSeparatorTokens);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the non-separator tokens list to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetNonSeparatorTokens() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/non-separator-tokens`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
  ///
  /// DICTIONARY
  ///
  /**
   * Get the dictionary settings of a Meilisearch index.
   *
   * @returns Promise containing the dictionary settings
   */
  getDictionary() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/dictionary`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Update the the dictionary settings. Overwrite the old settings.
   *
   * @param dictionary - Array that contains the new dictionary settings.
   * @returns Promise containing an EnqueuedTask or null
   */
  updateDictionary(dictionary) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/dictionary`;
      const task = yield this.httpRequest.put(url, dictionary);
      return new EnqueuedTask(task);
    });
  }
  /**
   * Reset the dictionary settings to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  resetDictionary() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes/${this.uid}/settings/dictionary`;
      const task = yield this.httpRequest.delete(url);
      task.enqueuedAt = new Date(task.enqueuedAt);
      return task;
    });
  }
};
var Client = class {
  /**
   * Creates new MeiliSearch instance
   *
   * @param config - Configuration object
   */
  constructor(config) {
    this.config = config;
    this.httpRequest = new HttpRequests(config);
    this.tasks = new TaskClient(config);
  }
  /**
   * Return an Index instance
   *
   * @param indexUid - The index UID
   * @returns Instance of Index
   */
  index(indexUid) {
    return new Index(this.config, indexUid);
  }
  /**
   * Gather information about an index by calling MeiliSearch and return an
   * Index instance with the gathered information
   *
   * @param indexUid - The index UID
   * @returns Promise returning Index instance
   */
  getIndex(indexUid) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Index(this.config, indexUid).fetchInfo();
    });
  }
  /**
   * Gather information about an index by calling MeiliSearch and return the raw
   * JSON response
   *
   * @param indexUid - The index UID
   * @returns Promise returning index information
   */
  getRawIndex(indexUid) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Index(this.config, indexUid).getRawInfo();
    });
  }
  /**
   * Get all the indexes as Index instances.
   *
   * @param parameters - Parameters to browse the indexes
   * @returns Promise returning array of raw index information
   */
  getIndexes(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const rawIndexes = yield this.getRawIndexes(parameters);
      const indexes = rawIndexes.results.map((index) => new Index(this.config, index.uid, index.primaryKey));
      return Object.assign(Object.assign({}, rawIndexes), { results: indexes });
    });
  }
  /**
   * Get all the indexes in their raw value (no Index instances).
   *
   * @param parameters - Parameters to browse the indexes
   * @returns Promise returning array of raw index information
   */
  getRawIndexes(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `indexes`;
      return yield this.httpRequest.get(url, parameters);
    });
  }
  /**
   * Create a new index
   *
   * @param uid - The index UID
   * @param options - Index options
   * @returns Promise returning Index instance
   */
  createIndex(uid, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield Index.create(uid, options, this.config);
    });
  }
  /**
   * Update an index
   *
   * @param uid - The index UID
   * @param options - Index options to update
   * @returns Promise returning Index instance after updating
   */
  updateIndex(uid, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield new Index(this.config, uid).update(options);
    });
  }
  /**
   * Delete an index
   *
   * @param uid - The index UID
   * @returns Promise which resolves when index is deleted successfully
   */
  deleteIndex(uid) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield new Index(this.config, uid).delete();
    });
  }
  /**
   * Deletes an index if it already exists.
   *
   * @param uid - The index UID
   * @returns Promise which resolves to true when index exists and is deleted
   *   successfully, otherwise false if it does not exist
   */
  deleteIndexIfExists(uid) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.deleteIndex(uid);
        return true;
      } catch (e) {
        if (e.code === "index_not_found") {
          return false;
        }
        throw e;
      }
    });
  }
  /**
   * Swaps a list of index tuples.
   *
   * @param params - List of indexes tuples to swap.
   * @returns Promise returning object of the enqueued task
   */
  swapIndexes(params) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = "/swap-indexes";
      return yield this.httpRequest.post(url, params);
    });
  }
  ///
  /// Multi Search
  ///
  /**
   * Perform multiple search queries.
   *
   * It is possible to make multiple search queries on the same index or on
   * different ones
   *
   * @example
   *
   * ```ts
   * client.multiSearch({
   *   queries: [
   *     { indexUid: 'movies', q: 'wonder' },
   *     { indexUid: 'books', q: 'flower' },
   *   ],
   * })
   * ```
   *
   * @param queries - Search queries
   * @param config - Additional request configuration options
   * @returns Promise containing the search responses
   */
  multiSearch(queries, config) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `multi-search`;
      return yield this.httpRequest.post(url, queries, void 0, config);
    });
  }
  ///
  /// TASKS
  ///
  /**
   * Get the list of all client tasks
   *
   * @param parameters - Parameters to browse the tasks
   * @returns Promise returning all tasks
   */
  getTasks(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.getTasks(parameters);
    });
  }
  /**
   * Get one task on the client scope
   *
   * @param taskUid - Task identifier
   * @returns Promise returning a task
   */
  getTask(taskUid) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.getTask(taskUid);
    });
  }
  /**
   * Wait for multiple tasks to be finished.
   *
   * @param taskUids - Tasks identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise returning an array of tasks
   */
  waitForTasks(taskUids, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.waitForTasks(taskUids, {
        timeOutMs,
        intervalMs
      });
    });
  }
  /**
   * Wait for a task to be finished.
   *
   * @param taskUid - Task identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise returning an array of tasks
   */
  waitForTask(taskUid, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.waitForTask(taskUid, {
        timeOutMs,
        intervalMs
      });
    });
  }
  /**
   * Cancel a list of enqueued or processing tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  cancelTasks(parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.cancelTasks(parameters);
    });
  }
  /**
   * Delete a list of tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  deleteTasks(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.tasks.deleteTasks(parameters);
    });
  }
  ///
  /// KEYS
  ///
  /**
   * Get all API keys
   *
   * @param parameters - Parameters to browse the indexes
   * @returns Promise returning an object with keys
   */
  getKeys(parameters = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `keys`;
      const keys = yield this.httpRequest.get(url, parameters);
      keys.results = keys.results.map((key) => Object.assign(Object.assign({}, key), { createdAt: new Date(key.createdAt), updatedAt: new Date(key.updatedAt) }));
      return keys;
    });
  }
  /**
   * Get one API key
   *
   * @param keyOrUid - Key or uid of the API key
   * @returns Promise returning a key
   */
  getKey(keyOrUid) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `keys/${keyOrUid}`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Create one API key
   *
   * @param options - Key options
   * @returns Promise returning a key
   */
  createKey(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `keys`;
      return yield this.httpRequest.post(url, options);
    });
  }
  /**
   * Update one API key
   *
   * @param keyOrUid - Key
   * @param options - Key options
   * @returns Promise returning a key
   */
  updateKey(keyOrUid, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `keys/${keyOrUid}`;
      return yield this.httpRequest.patch(url, options);
    });
  }
  /**
   * Delete one API key
   *
   * @param keyOrUid - Key
   * @returns
   */
  deleteKey(keyOrUid) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `keys/${keyOrUid}`;
      return yield this.httpRequest.delete(url);
    });
  }
  ///
  /// HEALTH
  ///
  /**
   * Checks if the server is healthy, otherwise an error will be thrown.
   *
   * @returns Promise returning an object with health details
   */
  health() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `health`;
      return yield this.httpRequest.get(url);
    });
  }
  /**
   * Checks if the server is healthy, return true or false.
   *
   * @returns Promise returning a boolean
   */
  isHealthy() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const url = `health`;
        yield this.httpRequest.get(url);
        return true;
      } catch (e) {
        return false;
      }
    });
  }
  ///
  /// STATS
  ///
  /**
   * Get the stats of all the database
   *
   * @returns Promise returning object of all the stats
   */
  getStats() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `stats`;
      return yield this.httpRequest.get(url);
    });
  }
  ///
  /// VERSION
  ///
  /**
   * Get the version of MeiliSearch
   *
   * @returns Promise returning object with version details
   */
  getVersion() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `version`;
      return yield this.httpRequest.get(url);
    });
  }
  ///
  /// DUMPS
  ///
  /**
   * Creates a dump
   *
   * @returns Promise returning object of the enqueued task
   */
  createDump() {
    return __awaiter(this, void 0, void 0, function* () {
      const url = `dumps`;
      const task = yield this.httpRequest.post(url);
      return new EnqueuedTask(task);
    });
  }
  ///
  /// TOKENS
  ///
  /**
   * Generate a tenant token
   *
   * @param apiKeyUid - The uid of the api key used as issuer of the token.
   * @param searchRules - Search rules that are applied to every search.
   * @param options - Token options to customize some aspect of the token.
   * @returns The token in JWT format.
   */
  generateTenantToken(_apiKeyUid, _searchRules, _options) {
    const error = new Error();
    throw new Error(`Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment 
 ${error.stack}.`);
  }
};
function encode64(data) {
  return Buffer.from(JSON.stringify(data)).toString("base64");
}
function sign(apiKey, encodedHeader, encodedPayload) {
  return import_crypto.default.createHmac("sha256", apiKey).update(`${encodedHeader}.${encodedPayload}`).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function createHeader() {
  const header = {
    alg: "HS256",
    typ: "JWT"
  };
  return encode64(header).replace(/=/g, "");
}
function validateTokenParameters(tokenParams) {
  const { searchRules, uid, apiKey, expiresAt } = tokenParams;
  if (expiresAt) {
    if (!(expiresAt instanceof Date)) {
      throw new MeiliSearchError(`Meilisearch: The expiredAt field must be an instance of Date.`);
    } else if (expiresAt.getTime() < Date.now()) {
      throw new MeiliSearchError(`Meilisearch: The expiresAt field must be a date in the future.`);
    }
  }
  if (searchRules) {
    if (!(typeof searchRules === "object" || Array.isArray(searchRules))) {
      throw new MeiliSearchError(`Meilisearch: The search rules added in the token generation must be of type array or object.`);
    }
  }
  if (!apiKey || typeof apiKey !== "string") {
    throw new MeiliSearchError(`Meilisearch: The API key used for the token generation must exist and be of type string.`);
  }
  if (!uid || typeof uid !== "string") {
    throw new MeiliSearchError(`Meilisearch: The uid of the api key used for the token generation must exist, be of type string and comply to the uuid4 format.`);
  }
  if (!validateUuid4(uid)) {
    throw new MeiliSearchError(`Meilisearch: The uid of your key is not a valid uuid4. To find out the uid of your key use getKey().`);
  }
}
function createPayload(payloadParams) {
  const { searchRules, uid, expiresAt } = payloadParams;
  const payload = {
    searchRules,
    apiKeyUid: uid,
    exp: expiresAt ? Math.floor(expiresAt.getTime() / 1e3) : void 0
  };
  return encode64(payload).replace(/=/g, "");
}
var Token = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Generate a tenant token
   *
   * @param apiKeyUid - The uid of the api key used as issuer of the token.
   * @param searchRules - Search rules that are applied to every search.
   * @param options - Token options to customize some aspect of the token.
   * @returns The token in JWT format.
   */
  generateTenantToken(apiKeyUid, searchRules, options) {
    const apiKey = (options === null || options === void 0 ? void 0 : options.apiKey) || this.config.apiKey || "";
    const uid = apiKeyUid || "";
    const expiresAt = options === null || options === void 0 ? void 0 : options.expiresAt;
    validateTokenParameters({ apiKey, uid, expiresAt, searchRules });
    const encodedHeader = createHeader();
    const encodedPayload = createPayload({ searchRules, uid, expiresAt });
    const signature = sign(apiKey, encodedHeader, encodedPayload);
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  }
};
var MeiliSearch = class extends Client {
  constructor(config) {
    super(config);
    this.tokens = new Token(config);
  }
  /**
   * Generate a tenant token
   *
   * @param apiKeyUid - The uid of the api key used as issuer of the token.
   * @param searchRules - Search rules that are applied to every search.
   * @param options - Token options to customize some aspect of the token.
   * @returns The token in JWT format.
   */
  generateTenantToken(apiKeyUid, searchRules, options) {
    if (typeof window === "undefined") {
      return this.tokens.generateTenantToken(apiKeyUid, searchRules, options);
    }
    return super.generateTenantToken(apiKeyUid, searchRules, options);
  }
};
export {
  ContentTypeEnum,
  EnqueuedTask,
  Index,
  MatchingStrategies,
  MeiliSearch,
  MeiliSearchApiError,
  MeiliSearchCommunicationError,
  MeiliSearchError,
  MeiliSearchTimeOutError,
  Task,
  TaskClient,
  MeiliSearch as default,
  httpErrorHandler,
  httpResponseErrorHandler,
  versionErrorHintMessage
};
//# sourceMappingURL=meilisearch.js.map
