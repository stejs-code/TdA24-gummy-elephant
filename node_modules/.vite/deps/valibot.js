import {
  __publicField
} from "./chunk-TCQZMY3T.js";

// node_modules/valibot/dist/index.js
function flatten(arg1) {
  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(
    (flatErrors, issue) => {
      if (issue.path) {
        if (issue.path.every(
          ({ key }) => typeof key === "string" || typeof key === "number"
        )) {
          const path = issue.path.map(({ key }) => key).join(".");
          if (flatErrors.nested[path]) {
            flatErrors.nested[path].push(issue.message);
          } else {
            flatErrors.nested[path] = [issue.message];
          }
        }
      } else {
        if (flatErrors.root) {
          flatErrors.root.push(issue.message);
        } else {
          flatErrors.root = [issue.message];
        }
      }
      return flatErrors;
    },
    { nested: {} }
  );
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
var BrandSymbol = Symbol("brand");
function brand(schema, name) {
  return schema;
}
function coerce(schema, action) {
  return {
    ...schema,
    _parse(input, info) {
      return schema._parse(action(input), info);
    }
  };
}
function coerceAsync(schema, action) {
  return {
    ...schema,
    async _parse(input, info) {
      return schema._parse(await action(input), info);
    }
  };
}
function getIssues(issues) {
  return { issues };
}
function getOutput(output) {
  return { output };
}
function getIssue(info, issue) {
  return {
    reason: info == null ? void 0 : info.reason,
    validation: issue.validation,
    origin: (info == null ? void 0 : info.origin) || "value",
    message: issue.message,
    input: issue.input,
    path: issue.path,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function getPipeInfo(info, reason) {
  return {
    reason,
    origin: info == null ? void 0 : info.origin,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function executePipe(input, pipe, parseInfo, reason) {
  if (!pipe || !pipe.length || (parseInfo == null ? void 0 : parseInfo.skipPipe)) {
    return getOutput(input);
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe) {
    const result = action._parse(output);
    if (result.issues) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      for (const issueInfo of result.issues) {
        const issue = getIssue(pipeInfo, issueInfo);
        issues ? issues.push(issue) : issues = [issue];
      }
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? getIssues(issues) : getOutput(output);
}
async function executePipeAsync(input, pipe, parseInfo, reason) {
  if (!pipe || !pipe.length || (parseInfo == null ? void 0 : parseInfo.skipPipe)) {
    return getOutput(input);
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe) {
    const result = await action._parse(output);
    if (result.issues) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      for (const issueInfo of result.issues) {
        const issue = getIssue(pipeInfo, issueInfo);
        issues ? issues.push(issue) : issues = [issue];
      }
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? getIssues(issues) : getOutput(output);
}
function getDefaultArgs(arg1, arg2) {
  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
}
function getErrorMessage(message) {
  return typeof message === "function" ? message() : message;
}
function getPipeIssues(validation, message, input, requirement) {
  return getIssues([
    {
      validation,
      message: getErrorMessage(message),
      input,
      requirement
    }
  ]);
}
function getRestAndDefaultArgs(arg1, arg2, arg3) {
  if (!arg1 || typeof arg1 === "object" && !Array.isArray(arg1)) {
    const [error2, pipe2] = getDefaultArgs(arg2, arg3);
    return [arg1, error2, pipe2];
  }
  const [error, pipe] = getDefaultArgs(
    arg1,
    arg2
  );
  return [void 0, error, pipe];
}
function getSchemaIssues(info, reason, validation, message, input, issues) {
  return {
    issues: [
      {
        reason,
        validation,
        origin: (info == null ? void 0 : info.origin) || "value",
        message: getErrorMessage(message),
        input,
        issues,
        abortEarly: info == null ? void 0 : info.abortEarly,
        abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
        skipPipe: info == null ? void 0 : info.skipPipe
      }
    ]
  };
}
var NON_DIGIT_REGEX = /\D/gu;
function isLuhnAlgo(input) {
  const number2 = input.replaceAll(NON_DIGIT_REGEX, "");
  let length2 = number2.length;
  let bit = 1;
  let sum = 0;
  while (length2) {
    const value2 = +number2[--length2];
    bit ^= 1;
    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
  }
  return sum % 10 === 0;
}
function getFallback(schema, info) {
  return typeof schema.fallback === "function" ? schema.fallback(info) : schema.fallback;
}
async function getFallbackAsync(schema, info) {
  return typeof schema.fallback === "function" ? await schema.fallback(info) : schema.fallback;
}
function fallback(schema, fallback2) {
  return {
    ...schema,
    fallback: fallback2,
    _parse(input, info) {
      const result = schema._parse(input, info);
      return getOutput(
        result.issues ? getFallback(this, { input, issues: result.issues }) : result.output
      );
    }
  };
}
function fallbackAsync(schema, fallback2) {
  return {
    ...schema,
    fallback: fallback2,
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      return getOutput(
        result.issues ? await getFallbackAsync(this, { input, issues: result.issues }) : result.output
      );
    }
  };
}
function getDefault(schema) {
  return typeof schema.default === "function" ? schema.default() : schema.default;
}
async function getDefaultAsync(schema) {
  return typeof schema.default === "function" ? await schema.default() : schema.default;
}
function getDefaults(schema) {
  let defaults;
  if (schema.default) {
    defaults = getDefault(schema);
  } else if ("type" in schema) {
    if (schema.type === "object") {
      defaults = {};
      for (const key in schema.entries) {
        defaults[key] = getDefaults(schema.entries[key]);
      }
    } else if (schema.type === "tuple") {
      defaults = [];
      for (let key = 0; key < schema.items.length; key++) {
        defaults.push(getDefaults(schema.items[key]));
      }
    }
  }
  return defaults;
}
async function getDefaultsAsync(schema) {
  let defaults;
  if (schema.default) {
    defaults = await getDefaultAsync(schema);
  } else if ("type" in schema) {
    if (schema.type === "object") {
      defaults = {};
      for (const key in schema.entries) {
        defaults[key] = await getDefaultsAsync(schema.entries[key]);
      }
    } else if (schema.type === "tuple") {
      defaults = [];
      for (let key = 0; key < schema.items.length; key++) {
        defaults.push(await getDefaultsAsync(schema.items[key]));
      }
    }
  }
  return defaults;
}
function getFallbacks(schema) {
  let fallbacks;
  if (schema.fallback) {
    fallbacks = getFallback(schema);
  } else if ("type" in schema) {
    if (schema.type === "object") {
      fallbacks = {};
      for (const key in schema.entries) {
        fallbacks[key] = getFallbacks(schema.entries[key]);
      }
    } else if (schema.type === "tuple") {
      fallbacks = [];
      for (let key = 0; key < schema.items.length; key++) {
        fallbacks.push(getFallbacks(schema.items[key]));
      }
    }
  }
  return fallbacks;
}
async function getFallbacksAsync(schema) {
  let fallbacks;
  if (schema.fallback) {
    fallbacks = await getFallbackAsync(schema);
  } else if ("type" in schema) {
    if (schema.type === "object") {
      fallbacks = {};
      await Promise.all(
        Object.entries(schema.entries).map(async ([key, schema2]) => {
          fallbacks[key] = await getFallbacksAsync(schema2);
        })
      );
    } else if (schema.type === "tuple") {
      fallbacks = await Promise.all(
        schema.items.map((schema2) => getFallbacksAsync(schema2))
      );
    }
  }
  return fallbacks;
}
function is(schema, input) {
  return !schema._parse(input, { abortEarly: true }).issues;
}
function any(pipe) {
  return {
    type: "any",
    async: false,
    pipe,
    _parse(input, info) {
      return executePipe(input, this.pipe, info, "any");
    }
  };
}
function anyAsync(pipe) {
  return {
    type: "any",
    async: true,
    pipe,
    async _parse(input, info) {
      return executePipeAsync(input, this.pipe, info, "any");
    }
  };
}
function array(item, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "array",
    async: false,
    item,
    message,
    pipe,
    _parse(input, info) {
      if (!Array.isArray(input)) {
        return getSchemaIssues(info, "type", "array", this.message, input);
      }
      let issues;
      const output = [];
      for (let key = 0; key < input.length; key++) {
        const value2 = input[key];
        const result = this.item._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            type: "array",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          output.push(result.output);
        }
      }
      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, "array");
    }
  };
}
function arrayAsync(item, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "array",
    async: true,
    item,
    message,
    pipe,
    async _parse(input, info) {
      if (!Array.isArray(input)) {
        return getSchemaIssues(info, "type", "array", this.message, input);
      }
      let issues;
      const output = [];
      await Promise.all(
        input.map(async (value2, key) => {
          if (!((info == null ? void 0 : info.abortEarly) && issues)) {
            const result = await this.item._parse(value2, info);
            if (!((info == null ? void 0 : info.abortEarly) && issues)) {
              if (result.issues) {
                const pathItem = {
                  type: "array",
                  input,
                  key,
                  value: value2
                };
                for (const issue of result.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues == null ? void 0 : issues.push(issue);
                }
                if (!issues) {
                  issues = result.issues;
                }
                if (info == null ? void 0 : info.abortEarly) {
                  throw null;
                }
              } else {
                output[key] = result.output;
              }
            }
          }
        })
      ).catch(() => null);
      return issues ? getIssues(issues) : executePipeAsync(output, this.pipe, info, "array");
    }
  };
}
function bigint(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "bigint",
    async: false,
    message,
    pipe,
    _parse(input, info) {
      if (typeof input !== "bigint") {
        return getSchemaIssues(info, "type", "bigint", this.message, input);
      }
      return executePipe(input, this.pipe, info, "bigint");
    }
  };
}
function bigintAsync(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "bigint",
    async: true,
    message,
    pipe,
    async _parse(input, info) {
      if (typeof input !== "bigint") {
        return getSchemaIssues(info, "type", "bigint", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "bigint");
    }
  };
}
function blob(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "blob",
    async: false,
    message,
    pipe,
    _parse(input, info) {
      if (!(input instanceof Blob)) {
        return getSchemaIssues(info, "type", "blob", this.message, input);
      }
      return executePipe(input, this.pipe, info, "blob");
    }
  };
}
function blobAsync(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "blob",
    async: true,
    message,
    pipe,
    async _parse(input, info) {
      if (!(input instanceof Blob)) {
        return getSchemaIssues(info, "type", "blob", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "blob");
    }
  };
}
function boolean(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "boolean",
    async: false,
    message,
    pipe,
    _parse(input, info) {
      if (typeof input !== "boolean") {
        return getSchemaIssues(info, "type", "boolean", this.message, input);
      }
      return executePipe(input, this.pipe, info, "boolean");
    }
  };
}
function booleanAsync(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "boolean",
    async: true,
    message,
    pipe,
    async _parse(input, info) {
      if (typeof input !== "boolean") {
        return getSchemaIssues(info, "type", "boolean", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "boolean");
    }
  };
}
function date(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "date",
    async: false,
    message,
    pipe,
    _parse(input, info) {
      if (!(input instanceof Date) || isNaN(input.getTime())) {
        return getSchemaIssues(info, "type", "date", this.message, input);
      }
      return executePipe(input, this.pipe, info, "date");
    }
  };
}
function dateAsync(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "date",
    async: true,
    message,
    pipe,
    async _parse(input, info) {
      if (!(input instanceof Date) || isNaN(input.getTime())) {
        return getSchemaIssues(info, "type", "date", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "date");
    }
  };
}
function enum_(enum_2, message = "Invalid type") {
  return {
    type: "enum",
    async: false,
    enum: enum_2,
    message,
    _parse(input, info) {
      if (!Object.values(this.enum).includes(input)) {
        return getSchemaIssues(info, "type", "enum", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var nativeEnum = enum_;
function enumAsync(enum_2, message = "Invalid type") {
  return {
    type: "enum",
    async: true,
    enum: enum_2,
    message,
    async _parse(input, info) {
      if (!Object.values(this.enum).includes(input)) {
        return getSchemaIssues(info, "type", "enum", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var nativeEnumAsync = enumAsync;
function instance(class_, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "instance",
    async: false,
    class: class_,
    message,
    pipe,
    _parse(input, info) {
      if (!(input instanceof this.class)) {
        return getSchemaIssues(info, "type", "instance", this.message, input);
      }
      return executePipe(input, this.pipe, info, "instance");
    }
  };
}
function instanceAsync(class_, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "instance",
    async: true,
    class: class_,
    message,
    pipe,
    async _parse(input, info) {
      if (!(input instanceof this.class)) {
        return getSchemaIssues(info, "type", "instance", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "instance");
    }
  };
}
function mergeOutputs(output1, output2) {
  if (typeof output1 === typeof output2) {
    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {
      return getOutput(output1);
    }
    if (Array.isArray(output1) && Array.isArray(output2)) {
      if (output1.length === output2.length) {
        const array2 = [];
        for (let index = 0; index < output1.length; index++) {
          const result = mergeOutputs(output1[index], output2[index]);
          if (result.invalid) {
            return result;
          }
          array2.push(result.output);
        }
        return getOutput(array2);
      }
      return { invalid: true };
    }
    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {
      const object2 = { ...output1, ...output2 };
      for (const key in output1) {
        if (key in output2) {
          const result = mergeOutputs(output1[key], output2[key]);
          if (result.invalid) {
            return result;
          }
          object2[key] = result.output;
        }
      }
      return getOutput(object2);
    }
  }
  return { invalid: true };
}
function intersect(options, message = "Invalid type") {
  return {
    type: "intersect",
    async: false,
    options,
    message,
    _parse(input, info) {
      let issues;
      let outputs;
      for (const schema of this.options) {
        const result = schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          if (outputs) {
            outputs.push(result.output);
          } else {
            outputs = [result.output];
          }
        }
      }
      if (issues) {
        return getIssues(issues);
      }
      let output = outputs[0];
      for (let index = 1; index < outputs.length; index++) {
        const result = mergeOutputs(output, outputs[index]);
        if (result.invalid) {
          return getSchemaIssues(
            info,
            "type",
            "intersect",
            this.message,
            input
          );
        }
        output = result.output;
      }
      return getOutput(output);
    }
  };
}
var intersection = intersect;
function literal(literal2, message = "Invalid type") {
  return {
    type: "literal",
    async: false,
    literal: literal2,
    message,
    _parse(input, info) {
      if (input !== this.literal) {
        return getSchemaIssues(info, "type", "literal", this.message, input);
      }
      return getOutput(input);
    }
  };
}
function literalAsync(literal2, message = "Invalid type") {
  return {
    type: "literal",
    async: true,
    literal: literal2,
    message,
    async _parse(input, info) {
      if (input !== this.literal) {
        return getSchemaIssues(info, "type", "literal", this.message, input);
      }
      return getOutput(input);
    }
  };
}
function map(key, value2, arg3, arg4) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg3, arg4);
  return {
    type: "map",
    async: false,
    key,
    value: value2,
    message,
    pipe,
    _parse(input, info) {
      if (!(input instanceof Map)) {
        return getSchemaIssues(info, "type", "map", this.message, input);
      }
      let issues;
      const output = /* @__PURE__ */ new Map();
      for (const [inputKey, inputValue] of input.entries()) {
        let pathItem;
        const keyResult = this.key._parse(inputKey, {
          origin: "key",
          abortEarly: info == null ? void 0 : info.abortEarly,
          abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
          skipPipe: info == null ? void 0 : info.skipPipe
        });
        if (keyResult.issues) {
          pathItem = {
            type: "map",
            input,
            key: inputKey,
            value: inputValue
          };
          for (const issue of keyResult.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = keyResult.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        }
        const valueResult = this.value._parse(inputValue, info);
        if (valueResult.issues) {
          pathItem = pathItem || {
            type: "map",
            input,
            key: inputKey,
            value: inputValue
          };
          for (const issue of valueResult.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = valueResult.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        }
        if (!keyResult.issues && !valueResult.issues) {
          output.set(keyResult.output, valueResult.output);
        }
      }
      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, "map");
    }
  };
}
function mapAsync(key, value2, arg3, arg4) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg3, arg4);
  return {
    type: "map",
    async: true,
    key,
    value: value2,
    message,
    pipe,
    async _parse(input, info) {
      if (!(input instanceof Map)) {
        return getSchemaIssues(info, "type", "map", this.message, input);
      }
      const output = /* @__PURE__ */ new Map();
      let issues;
      await Promise.all(
        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {
          let pathItem;
          const [keyResult, valueResult] = await Promise.all(
            [
              { schema: this.key, value: inputKey, origin: "key" },
              { schema: this.value, value: inputValue, origin: "value" }
            ].map(async ({ schema, value: value3, origin }) => {
              if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                const result = await schema._parse(value3, {
                  origin,
                  abortEarly: info == null ? void 0 : info.abortEarly,
                  abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
                  skipPipe: info == null ? void 0 : info.skipPipe
                });
                if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                  if (result.issues) {
                    pathItem = pathItem || {
                      type: "map",
                      input,
                      key: inputKey,
                      value: inputValue
                    };
                    for (const issue of result.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      issues == null ? void 0 : issues.push(issue);
                    }
                    if (!issues) {
                      issues = result.issues;
                    }
                    if (info == null ? void 0 : info.abortEarly) {
                      throw null;
                    }
                  } else {
                    return result;
                  }
                }
              }
            })
          ).catch(() => []);
          if (keyResult && valueResult) {
            output.set(keyResult.output, valueResult.output);
          }
        })
      );
      return issues ? getIssues(issues) : executePipeAsync(input, this.pipe, info, "map");
    }
  };
}
function nan(message = "Invalid type") {
  return {
    type: "nan",
    async: false,
    message,
    _parse(input, info) {
      if (!Number.isNaN(input)) {
        return getSchemaIssues(info, "type", "nan", this.message, input);
      }
      return getOutput(input);
    }
  };
}
function nanAsync(message = "Invalid type") {
  return {
    type: "nan",
    async: true,
    message,
    async _parse(input, info) {
      if (!Number.isNaN(input)) {
        return getSchemaIssues(info, "type", "nan", this.message, input);
      }
      return getOutput(input);
    }
  };
}
function never(message = "Invalid type") {
  return {
    type: "never",
    async: false,
    message,
    _parse(input, info) {
      return getSchemaIssues(info, "type", "never", this.message, input);
    }
  };
}
function neverAsync(message = "Invalid type") {
  return {
    type: "never",
    async: true,
    message,
    async _parse(input, info) {
      return getSchemaIssues(info, "type", "never", this.message, input);
    }
  };
}
function nonNullable(wrapped, message = "Invalid type") {
  return {
    type: "non_nullable",
    async: false,
    wrapped,
    message,
    _parse(input, info) {
      if (input === null) {
        return getSchemaIssues(
          info,
          "type",
          "non_nullable",
          this.message,
          input
        );
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nonNullableAsync(wrapped, message = "Invalid type") {
  return {
    type: "non_nullable",
    async: true,
    wrapped,
    message,
    async _parse(input, info) {
      if (input === null) {
        return getSchemaIssues(
          info,
          "type",
          "non_nullable",
          this.message,
          input
        );
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nonNullish(wrapped, message = "Invalid type") {
  return {
    type: "non_nullish",
    async: false,
    wrapped,
    message,
    _parse(input, info) {
      if (input === null || input === void 0) {
        return getSchemaIssues(
          info,
          "type",
          "non_nullish",
          this.message,
          input
        );
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nonNullishAsync(wrapped, message = "Invalid type") {
  return {
    type: "non_nullish",
    async: true,
    wrapped,
    message,
    async _parse(input, info) {
      if (input === null || input === void 0) {
        return getSchemaIssues(
          info,
          "type",
          "non_nullish",
          this.message,
          input
        );
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nonOptional(wrapped, message = "Invalid type") {
  return {
    type: "non_optional",
    async: false,
    wrapped,
    message,
    _parse(input, info) {
      if (input === void 0) {
        return getSchemaIssues(
          info,
          "type",
          "non_optional",
          this.message,
          input
        );
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nonOptionalAsync(wrapped, message = "Invalid type") {
  return {
    type: "non_optional",
    async: true,
    wrapped,
    message,
    async _parse(input, info) {
      if (input === void 0) {
        return getSchemaIssues(
          info,
          "type",
          "non_optional",
          this.message,
          input
        );
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nullable(wrapped, default_) {
  return {
    type: "nullable",
    async: false,
    wrapped,
    default: default_,
    _parse(input, info) {
      if (input === null) {
        const override = getDefault(this);
        if (override === void 0) {
          return getOutput(input);
        }
        input = override;
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nullableAsync(wrapped, default_) {
  return {
    type: "nullable",
    async: true,
    wrapped,
    default: default_,
    async _parse(input, info) {
      if (input === null) {
        const override = await getDefaultAsync(this);
        if (override === void 0) {
          return getOutput(input);
        }
        input = override;
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nullish(wrapped, default_) {
  return {
    type: "nullish",
    async: false,
    wrapped,
    default: default_,
    _parse(input, info) {
      if (input === null || input === void 0) {
        const override = getDefault(this);
        if (override === void 0) {
          return getOutput(input);
        }
        input = override;
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function nullishAsync(wrapped, default_) {
  return {
    type: "nullish",
    async: true,
    wrapped,
    default: default_,
    async _parse(input, info) {
      if (input === null || input === void 0) {
        const override = await getDefaultAsync(this);
        if (override === void 0) {
          return getOutput(input);
        }
        input = override;
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function null_(message = "Invalid type") {
  return {
    type: "null",
    async: false,
    message,
    _parse(input, info) {
      if (input !== null) {
        return getSchemaIssues(info, "type", "null", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var nullType = null_;
function nullAsync(message = "Invalid type") {
  return {
    type: "null",
    async: true,
    message,
    async _parse(input, info) {
      if (input !== null) {
        return getSchemaIssues(info, "type", "null", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var nullTypeAsync = nullAsync;
function number(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "number",
    async: false,
    message,
    pipe,
    _parse(input, info) {
      if (typeof input !== "number" || isNaN(input)) {
        return getSchemaIssues(info, "type", "number", this.message, input);
      }
      return executePipe(input, this.pipe, info, "number");
    }
  };
}
function numberAsync(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "number",
    async: true,
    message,
    pipe,
    async _parse(input, info) {
      if (typeof input !== "number" || isNaN(input)) {
        return getSchemaIssues(info, "type", "number", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "number");
    }
  };
}
function object(entries, arg2, arg3, arg4) {
  const [rest, message = "Invalid type", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  let cachedEntries;
  return {
    type: "object",
    async: false,
    entries,
    rest,
    message,
    pipe,
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(info, "type", "object", this.message, input);
      }
      cachedEntries = cachedEntries || Object.entries(this.entries);
      let issues;
      const output = {};
      for (const [key, schema] of cachedEntries) {
        const value2 = input[key];
        const result = schema._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            type: "object",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else if (result.output !== void 0 || key in input) {
          output[key] = result.output;
        }
      }
      if (this.rest && !((info == null ? void 0 : info.abortEarly) && issues)) {
        for (const key in input) {
          if (!(key in this.entries)) {
            const value2 = input[key];
            const result = this.rest._parse(value2, info);
            if (result.issues) {
              const pathItem = {
                type: "object",
                input,
                key,
                value: value2
              };
              for (const issue of result.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                issues == null ? void 0 : issues.push(issue);
              }
              if (!issues) {
                issues = result.issues;
              }
              if (info == null ? void 0 : info.abortEarly) {
                break;
              }
            } else {
              output[key] = result.output;
            }
          }
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        this.pipe,
        info,
        "object"
      );
    }
  };
}
function objectAsync(entries, arg2, arg3, arg4) {
  const [rest, message = "Invalid type", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  let cachedEntries;
  return {
    type: "object",
    async: true,
    entries,
    rest,
    message,
    pipe,
    async _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(info, "type", "object", this.message, input);
      }
      cachedEntries = cachedEntries || Object.entries(this.entries);
      let issues;
      const output = {};
      await Promise.all([
        Promise.all(
          cachedEntries.map(async ([key, schema]) => {
            if (!((info == null ? void 0 : info.abortEarly) && issues)) {
              const value2 = input[key];
              const result = await schema._parse(value2, info);
              if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                if (result.issues) {
                  const pathItem = {
                    type: "object",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of result.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    issues == null ? void 0 : issues.push(issue);
                  }
                  if (!issues) {
                    issues = result.issues;
                  }
                  if (info == null ? void 0 : info.abortEarly) {
                    throw null;
                  }
                } else if (result.output !== void 0 || key in input) {
                  output[key] = result.output;
                }
              }
            }
          })
        ),
        this.rest && Promise.all(
          Object.entries(input).map(async ([key, value2]) => {
            if (!((info == null ? void 0 : info.abortEarly) && issues)) {
              if (!(key in this.entries)) {
                const result = await this.rest._parse(value2, info);
                if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                  if (result.issues) {
                    const pathItem = {
                      type: "object",
                      input,
                      key,
                      value: value2
                    };
                    for (const issue of result.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      issues == null ? void 0 : issues.push(issue);
                    }
                    if (!issues) {
                      issues = result.issues;
                    }
                    if (info == null ? void 0 : info.abortEarly) {
                      throw null;
                    }
                  } else {
                    output[key] = result.output;
                  }
                }
              }
            }
          })
        )
      ]).catch(() => null);
      return issues ? getIssues(issues) : executePipeAsync(
        output,
        this.pipe,
        info,
        "object"
      );
    }
  };
}
function optional(wrapped, default_) {
  return {
    type: "optional",
    async: false,
    wrapped,
    default: default_,
    _parse(input, info) {
      if (input === void 0) {
        const override = getDefault(this);
        if (override === void 0) {
          return getOutput(input);
        }
        input = override;
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function optionalAsync(wrapped, default_) {
  return {
    type: "optional",
    async: true,
    wrapped,
    default: default_,
    async _parse(input, info) {
      if (input === void 0) {
        const override = await getDefaultAsync(this);
        if (override === void 0) {
          return getOutput(input);
        }
        input = override;
      }
      return this.wrapped._parse(input, info);
    }
  };
}
function picklist(options, message = "Invalid type") {
  return {
    type: "picklist",
    async: false,
    options,
    message,
    _parse(input, info) {
      if (!this.options.includes(input)) {
        return getSchemaIssues(info, "type", "picklist", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var enumType = picklist;
function picklistAsync(options, message = "Invalid type") {
  return {
    type: "picklist",
    async: true,
    options,
    message,
    async _parse(input, info) {
      if (!this.options.includes(input)) {
        return getSchemaIssues(info, "type", "picklist", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var enumTypeAsync = picklistAsync;
function string(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "string",
    async: false,
    message,
    pipe,
    _parse(input, info) {
      if (typeof input !== "string") {
        return getSchemaIssues(info, "type", "string", this.message, input);
      }
      return executePipe(input, this.pipe, info, "string");
    }
  };
}
function stringAsync(arg1, arg2) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
  return {
    type: "string",
    async: true,
    message,
    pipe,
    async _parse(input, info) {
      if (typeof input !== "string") {
        return getSchemaIssues(info, "type", "string", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "string");
    }
  };
}
function getRecordArgs(arg1, arg2, arg3, arg4) {
  if (typeof arg2 === "object" && !Array.isArray(arg2)) {
    const [message2, pipe2] = getDefaultArgs(arg3, arg4);
    return [arg1, arg2, message2, pipe2];
  }
  const [message, pipe] = getDefaultArgs(
    arg2,
    arg3
  );
  return [string(), arg1, message, pipe];
}
var BLOCKED_KEYS = ["__proto__", "prototype", "constructor"];
function record(arg1, arg2, arg3, arg4) {
  const [key, value2, message = "Invalid type", pipe] = getRecordArgs(arg1, arg2, arg3, arg4);
  return {
    type: "record",
    async: false,
    key,
    value: value2,
    message,
    pipe,
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(info, "type", "record", this.message, input);
      }
      let issues;
      const output = {};
      for (const [inputKey, inputValue] of Object.entries(input)) {
        if (!BLOCKED_KEYS.includes(inputKey)) {
          let pathItem;
          const keyResult = this.key._parse(inputKey, {
            origin: "key",
            abortEarly: info == null ? void 0 : info.abortEarly,
            abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
            skipPipe: info == null ? void 0 : info.skipPipe
          });
          if (keyResult.issues) {
            pathItem = {
              type: "record",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyResult.issues) {
              issue.path = [pathItem];
              issues == null ? void 0 : issues.push(issue);
            }
            if (!issues) {
              issues = keyResult.issues;
            }
            if (info == null ? void 0 : info.abortEarly) {
              break;
            }
          }
          const valueResult = this.value._parse(inputValue, info);
          if (valueResult.issues) {
            pathItem = pathItem || {
              type: "record",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueResult.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              issues == null ? void 0 : issues.push(issue);
            }
            if (!issues) {
              issues = valueResult.issues;
            }
            if (info == null ? void 0 : info.abortEarly) {
              break;
            }
          }
          if (!keyResult.issues && !valueResult.issues) {
            output[keyResult.output] = valueResult.output;
          }
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        this.pipe,
        info,
        "record"
      );
    }
  };
}
function recordAsync(arg1, arg2, arg3, arg4) {
  const [key, value2, message = "Invalid type", pipe] = getRecordArgs(arg1, arg2, arg3, arg4);
  return {
    type: "record",
    async: true,
    key,
    value: value2,
    message,
    pipe,
    async _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(info, "type", "record", this.message, input);
      }
      let issues;
      const output = {};
      await Promise.all(
        // Note: `Object.entries(...)` converts each key to a string
        Object.entries(input).map(async ([inputKey, inputValue]) => {
          if (!BLOCKED_KEYS.includes(inputKey)) {
            let pathItem;
            const [keyResult, valueResult] = await Promise.all(
              [
                { schema: this.key, value: inputKey, origin: "key" },
                { schema: this.value, value: inputValue, origin: "value" }
              ].map(async ({ schema, value: value3, origin }) => {
                if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                  const result = await schema._parse(value3, {
                    origin,
                    abortEarly: info == null ? void 0 : info.abortEarly,
                    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
                    skipPipe: info == null ? void 0 : info.skipPipe
                  });
                  if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                    if (result.issues) {
                      pathItem = pathItem || {
                        type: "record",
                        input,
                        key: inputKey,
                        value: inputValue
                      };
                      for (const issue of result.issues) {
                        if (issue.path) {
                          issue.path.unshift(pathItem);
                        } else {
                          issue.path = [pathItem];
                        }
                        issues == null ? void 0 : issues.push(issue);
                      }
                      if (!issues) {
                        issues = result.issues;
                      }
                      if (info == null ? void 0 : info.abortEarly) {
                        throw null;
                      }
                    } else {
                      return result;
                    }
                  }
                }
              })
            ).catch(() => []);
            if (keyResult && valueResult) {
              output[keyResult.output] = valueResult.output;
            }
          }
        })
      );
      return issues ? getIssues(issues) : executePipeAsync(
        output,
        this.pipe,
        info,
        "record"
      );
    }
  };
}
function recursive(getter) {
  return {
    type: "recursive",
    async: false,
    getter,
    _parse(input, info) {
      return this.getter()._parse(input, info);
    }
  };
}
function recursiveAsync(getter) {
  return {
    type: "recursive",
    async: true,
    getter,
    async _parse(input, info) {
      return this.getter()._parse(input, info);
    }
  };
}
function set(value2, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "set",
    async: false,
    value: value2,
    message,
    pipe,
    _parse(input, info) {
      if (!(input instanceof Set)) {
        return getSchemaIssues(info, "type", "set", this.message, input);
      }
      let key = 0;
      let issues;
      const output = /* @__PURE__ */ new Set();
      for (const inputValue of input) {
        const result = this.value._parse(inputValue, info);
        if (result.issues) {
          const pathItem = {
            type: "set",
            input,
            key,
            value: inputValue
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          output.add(result.output);
        }
        key++;
      }
      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, "set");
    }
  };
}
function setAsync(value2, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "set",
    async: true,
    value: value2,
    message,
    pipe,
    async _parse(input, info) {
      if (!(input instanceof Set)) {
        return getSchemaIssues(info, "type", "set", this.message, input);
      }
      let issues;
      const output = /* @__PURE__ */ new Set();
      await Promise.all(
        Array.from(input.values()).map(async (inputValue, key) => {
          if (!((info == null ? void 0 : info.abortEarly) && issues)) {
            const result = await this.value._parse(inputValue, info);
            if (!((info == null ? void 0 : info.abortEarly) && issues)) {
              if (result.issues) {
                const pathItem = {
                  type: "set",
                  input,
                  key,
                  value: inputValue
                };
                for (const issue of result.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues == null ? void 0 : issues.push(issue);
                }
                if (!issues) {
                  issues = result.issues;
                }
                if (info == null ? void 0 : info.abortEarly) {
                  throw null;
                }
              } else {
                output.add(result.output);
              }
            }
          }
        })
      ).catch(() => null);
      return issues ? getIssues(issues) : executePipeAsync(input, this.pipe, info, "set");
    }
  };
}
function special(check, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "special",
    async: false,
    check,
    message,
    pipe,
    _parse(input, info) {
      if (!this.check(input)) {
        return getSchemaIssues(info, "type", "special", this.message, input);
      }
      return executePipe(input, this.pipe, info, "special");
    }
  };
}
function specialAsync(check, arg2, arg3) {
  const [message = "Invalid type", pipe] = getDefaultArgs(arg2, arg3);
  return {
    type: "special",
    async: true,
    check,
    message,
    pipe,
    async _parse(input, info) {
      if (!await this.check(input)) {
        return getSchemaIssues(info, "type", "special", this.message, input);
      }
      return executePipeAsync(input, this.pipe, info, "special");
    }
  };
}
function symbol(message = "Invalid type") {
  return {
    type: "symbol",
    async: false,
    message,
    _parse(input, info) {
      if (typeof input !== "symbol") {
        return getSchemaIssues(info, "type", "symbol", this.message, input);
      }
      return getOutput(input);
    }
  };
}
function symbolAsync(message = "Invalid type") {
  return {
    type: "symbol",
    async: true,
    message,
    async _parse(input, info) {
      if (typeof input !== "symbol") {
        return getSchemaIssues(info, "type", "symbol", this.message, input);
      }
      return getOutput(input);
    }
  };
}
function tuple(items, arg2, arg3, arg4) {
  const [rest, message = "Invalid type", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return {
    type: "tuple",
    async: false,
    items,
    rest,
    message,
    pipe,
    _parse(input, info) {
      if (!Array.isArray(input) || this.items.length > input.length) {
        return getSchemaIssues(info, "type", "tuple", this.message, input);
      }
      let issues;
      const output = [];
      for (let key = 0; key < this.items.length; key++) {
        const value2 = input[key];
        const result = this.items[key]._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            type: "tuple",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          output[key] = result.output;
        }
      }
      if (this.rest && !((info == null ? void 0 : info.abortEarly) && issues)) {
        for (let key = this.items.length; key < input.length; key++) {
          const value2 = input[key];
          const result = this.rest._parse(value2, info);
          if (result.issues) {
            const pathItem = {
              type: "tuple",
              input,
              key,
              value: value2
            };
            for (const issue of result.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              issues == null ? void 0 : issues.push(issue);
            }
            if (!issues) {
              issues = result.issues;
            }
            if (info == null ? void 0 : info.abortEarly) {
              break;
            }
          } else {
            output[key] = result.output;
          }
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        this.pipe,
        info,
        "tuple"
      );
    }
  };
}
function tupleAsync(items, arg2, arg3, arg4) {
  const [rest, message = "Invalid type", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return {
    type: "tuple",
    async: true,
    items,
    rest,
    message,
    pipe,
    async _parse(input, info) {
      if (!Array.isArray(input) || this.items.length > input.length) {
        return getSchemaIssues(info, "type", "tuple", this.message, input);
      }
      let issues;
      const output = [];
      await Promise.all([
        // Parse schema of each tuple item
        Promise.all(
          this.items.map(async (schema, key) => {
            if (!((info == null ? void 0 : info.abortEarly) && issues)) {
              const value2 = input[key];
              const result = await schema._parse(value2, info);
              if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                if (result.issues) {
                  const pathItem = {
                    type: "tuple",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of result.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    issues == null ? void 0 : issues.push(issue);
                  }
                  if (!issues) {
                    issues = result.issues;
                  }
                  if (info == null ? void 0 : info.abortEarly) {
                    throw null;
                  }
                } else {
                  output[key] = result.output;
                }
              }
            }
          })
        ),
        // If necessary parse schema of each rest item
        this.rest && Promise.all(
          input.slice(this.items.length).map(async (value2, index) => {
            if (!((info == null ? void 0 : info.abortEarly) && issues)) {
              const key = this.items.length + index;
              const result = await this.rest._parse(value2, info);
              if (!((info == null ? void 0 : info.abortEarly) && issues)) {
                if (result.issues) {
                  const pathItem = {
                    type: "tuple",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of result.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    issues == null ? void 0 : issues.push(issue);
                  }
                  if (!issues) {
                    issues = result.issues;
                  }
                  if (info == null ? void 0 : info.abortEarly) {
                    throw null;
                  }
                } else {
                  output[key] = result.output;
                }
              }
            }
          })
        )
      ]).catch(() => null);
      return issues ? getIssues(issues) : executePipeAsync(
        output,
        this.pipe,
        info,
        "tuple"
      );
    }
  };
}
function undefined_(message = "Invalid type") {
  return {
    type: "undefined",
    async: false,
    message,
    _parse(input, info) {
      if (typeof input !== "undefined") {
        return getSchemaIssues(info, "type", "undefined", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var undefinedType = undefined_;
function undefinedAsync(message = "Invalid type") {
  return {
    type: "undefined",
    async: true,
    message,
    async _parse(input, info) {
      if (typeof input !== "undefined") {
        return getSchemaIssues(info, "type", "undefined", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var undefinedTypeAsync = undefinedAsync;
function union(options, message = "Invalid type") {
  return {
    type: "union",
    async: false,
    options,
    message,
    _parse(input, info) {
      let issues;
      let output;
      for (const schema of this.options) {
        const result = schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? getOutput(output[0]) : getSchemaIssues(info, "type", "union", this.message, input, issues);
    }
  };
}
function unionAsync(options, message = "Invalid type") {
  return {
    type: "union",
    async: true,
    options,
    message,
    async _parse(input, info) {
      let issues;
      let output;
      for (const schema of this.options) {
        const result = await schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? getOutput(output[0]) : getSchemaIssues(info, "type", "union", this.message, input, issues);
    }
  };
}
function unknown(pipe) {
  return {
    type: "unknown",
    async: false,
    pipe,
    _parse(input, info) {
      return executePipe(input, this.pipe, info, "unknown");
    }
  };
}
function unknownAsync(pipe) {
  return {
    type: "unknown",
    async: true,
    pipe,
    async _parse(input, info) {
      return executePipeAsync(input, this.pipe, info, "unknown");
    }
  };
}
function variant(key, options, message = "Invalid type") {
  return {
    type: "variant",
    async: false,
    key,
    options,
    message,
    _parse(input, info) {
      if (!input || typeof input !== "object" || !(this.key in input)) {
        return getSchemaIssues(info, "type", "variant", this.message, input);
      }
      let issues;
      let output;
      const parseOptions = (options2) => {
        for (const schema of options2) {
          if (schema.type === "object") {
            const result = schema.entries[this.key]._parse(
              input[this.key],
              info
            );
            if (!result.issues) {
              const result2 = schema._parse(input, info);
              if (result2.issues) {
                issues = result2.issues;
              } else {
                output = [result2.output];
              }
              break;
            }
          } else if (schema.type === "variant") {
            parseOptions(schema.options);
            if (issues || output) {
              break;
            }
          }
        }
      };
      parseOptions(this.options);
      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(info, "type", "variant", this.message, input);
    }
  };
}
var discriminatedUnion = variant;
function variantAsync(key, options, message = "Invalid type") {
  return {
    type: "variant",
    async: true,
    key,
    options,
    message,
    async _parse(input, info) {
      if (!input || typeof input !== "object" || !(this.key in input)) {
        return getSchemaIssues(info, "type", "variant", this.message, input);
      }
      let issues;
      let output;
      const parseOptions = async (options2) => {
        for (const schema of options2) {
          if (schema.type === "object") {
            const result = await schema.entries[this.key]._parse(
              input[this.key],
              info
            );
            if (!result.issues) {
              const result2 = await schema._parse(input, info);
              if (result2.issues) {
                issues = result2.issues;
              } else {
                output = [result2.output];
              }
              break;
            }
          } else if (schema.type === "variant") {
            await parseOptions(schema.options);
            if (issues || output) {
              break;
            }
          }
        }
      };
      await parseOptions(this.options);
      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(info, "type", "variant", this.message, input);
    }
  };
}
var discriminatedUnionAsync = variantAsync;
function void_(message = "Invalid type") {
  return {
    type: "void",
    async: false,
    message,
    _parse(input, info) {
      if (typeof input !== "undefined") {
        return getSchemaIssues(info, "type", "void", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var voidType = void_;
function voidAsync(message = "Invalid type") {
  return {
    type: "void",
    async: true,
    message,
    async _parse(input, info) {
      if (typeof input !== "undefined") {
        return getSchemaIssues(info, "type", "void", this.message, input);
      }
      return getOutput(input);
    }
  };
}
var voidTypeAsync = voidAsync;
function keyof(schema) {
  return picklist(
    Object.keys(schema.entries)
  );
}
function merge(schemas, arg2, arg3, arg4) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return object(
    schemas.reduce(
      (entries, schema) => ({ ...entries, ...schema.entries }),
      {}
    ),
    rest,
    message,
    pipe
  );
}
function mergeAsync(schemas, arg2, arg3, arg4) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return objectAsync(
    schemas.reduce(
      (entries, schema) => ({ ...entries, ...schema.entries }),
      {}
    ),
    rest,
    message,
    pipe
  );
}
function omit(schema, keys, arg3, arg4, arg5) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);
  return object(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },
      {}
    ),
    rest,
    message,
    pipe
  );
}
function omitAsync(schema, keys, arg3, arg4, arg5) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);
  return objectAsync(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },
      {}
    ),
    rest,
    message,
    pipe
  );
}
function parse(schema, input, info) {
  const result = schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}
async function parseAsync(schema, input, info) {
  const result = await schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}
function partial(schema, arg2, arg3, arg4) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return object(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => ({
        ...entries,
        [key]: optional(schema2)
      }),
      {}
    ),
    rest,
    message,
    pipe
  );
}
function partialAsync(schema, arg2, arg3, arg4) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return objectAsync(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => ({
        ...entries,
        [key]: optionalAsync(schema2)
      }),
      {}
    ),
    rest,
    message,
    pipe
  );
}
function passthrough(schema) {
  return {
    ...schema,
    _parse(input, info) {
      const result = schema._parse(input, info);
      return !result.issues ? getOutput({ ...input, ...result.output }) : result;
    }
  };
}
function passthroughAsync(schema) {
  return {
    ...schema,
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      return !result.issues ? getOutput({ ...input, ...result.output }) : result;
    }
  };
}
function pick(schema, keys, arg3, arg4, arg5) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);
  return object(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,
      {}
    ),
    rest,
    message,
    pipe
  );
}
function pickAsync(schema, keys, arg3, arg4, arg5) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);
  return objectAsync(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,
      {}
    ),
    rest,
    message,
    pipe
  );
}
function required(schema, arg2, arg3, arg4) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return object(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => ({
        ...entries,
        [key]: nonOptional(schema2)
      }),
      {}
    ),
    rest,
    message,
    pipe
  );
}
function requiredAsync(schema, arg2, arg3, arg4) {
  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
  return objectAsync(
    Object.entries(schema.entries).reduce(
      (entries, [key, schema2]) => ({
        ...entries,
        [key]: nonOptionalAsync(schema2)
      }),
      {}
    ),
    rest,
    message,
    pipe
  );
}
function safeParse(schema, input, info) {
  const result = schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}
async function safeParseAsync(schema, input, info) {
  const result = await schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}
function strict(schema, message = "Invalid keys") {
  return {
    ...schema,
    _parse(input, info) {
      const result = schema._parse(input, info);
      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(info, "object", "strict", message, input) : result;
    }
  };
}
function strictAsync(schema, message = "Invalid keys") {
  return {
    ...schema,
    message,
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(info, "object", "strict", message, input) : result;
    }
  };
}
function strip(schema) {
  let cachedKeys;
  return {
    ...schema,
    _parse(input, info) {
      const result = schema._parse(input, info);
      if (result.issues) {
        return result;
      }
      cachedKeys = cachedKeys || Object.keys(schema.entries);
      const output = {};
      for (const key of cachedKeys) {
        output[key] = result.output[key];
      }
      return getOutput(output);
    }
  };
}
function stripAsync(schema) {
  let cachedKeys;
  return {
    ...schema,
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      if (result.issues) {
        return result;
      }
      cachedKeys = cachedKeys || Object.keys(schema.entries);
      const output = {};
      for (const key of cachedKeys) {
        output[key] = result.output[key];
      }
      return getOutput(output);
    }
  };
}
function transform(schema, action, arg1) {
  return {
    ...schema,
    _parse(input, info) {
      const result = schema._parse(input, info);
      if (result.issues) {
        return result;
      }
      const output = action(result.output);
      if (arg1 && !Array.isArray(arg1)) {
        return arg1._parse(output, info);
      }
      return executePipe(output, arg1, info, typeof output);
    }
  };
}
function transformAsync(schema, action, arg1) {
  return {
    ...schema,
    async: true,
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      if (result.issues) {
        return result;
      }
      const output = await action(result.output);
      if (arg1 && !Array.isArray(arg1)) {
        return arg1._parse(output, info);
      }
      return executePipeAsync(output, arg1, info, typeof output);
    }
  };
}
function unwrap(schema) {
  return schema.wrapped;
}
function withDefault(schema, value2) {
  return {
    ...schema,
    _parse(input, info) {
      return schema._parse(
        input === void 0 ? typeof value2 === "function" ? value2() : value2 : input,
        info
      );
    }
  };
}
var useDefault = withDefault;
var CUID2_REGEX = /^[a-z][\da-z]*$/u;
var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
var EMOJI_REGEX = /^[\p{Extended_Pictographic}\p{Emoji_Component}]+$/u;
var IMEI_REGEX = /^\d{2}(?:[ /|-]?\d{6}){2}[ /|-]?\d$/u;
var IPV4_REGEX = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
  /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u
);
var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}\.\d{3}Z$/u;
var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
var ULID_REGEX = /^[\da-hjkmnp-tv-z]{26}$/iu;
var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
function toCustom(action) {
  return {
    type: "to_custom",
    async: false,
    _parse(input) {
      return getOutput(action(input));
    }
  };
}
function toCustomAsync(action) {
  return {
    type: "to_custom",
    async: true,
    async _parse(input) {
      return getOutput(await action(input));
    }
  };
}
function toLowerCase() {
  return {
    type: "to_lower_case",
    async: false,
    _parse(input) {
      return getOutput(input.toLocaleLowerCase());
    }
  };
}
function toMaxValue(requirement) {
  return {
    type: "to_max_value",
    async: false,
    requirement,
    _parse(input) {
      return getOutput(input > this.requirement ? this.requirement : input);
    }
  };
}
function toMinValue(requirement) {
  return {
    type: "to_min_value",
    async: false,
    requirement,
    _parse(input) {
      return getOutput(input < this.requirement ? this.requirement : input);
    }
  };
}
function toTrimmed() {
  return {
    type: "to_trimmed",
    async: false,
    _parse(input) {
      return getOutput(input.trim());
    }
  };
}
function toTrimmedEnd() {
  return {
    type: "to_trimmed_end",
    async: false,
    _parse(input) {
      return getOutput(input.trimEnd());
    }
  };
}
function toTrimmedStart() {
  return {
    type: "to_trimmed_start",
    async: false,
    _parse(input) {
      return getOutput(input.trimStart());
    }
  };
}
function toUpperCase() {
  return {
    type: "to_upper_case",
    async: false,
    _parse(input) {
      return getOutput(input.toUpperCase());
    }
  };
}
function bytes(requirement, message = "Invalid byte length") {
  return {
    type: "bytes",
    async: false,
    message,
    requirement,
    _parse(input) {
      return new TextEncoder().encode(input).length !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function cuid2(message = "Invalid Cuid2") {
  return {
    type: "cuid2",
    async: false,
    message,
    requirement: CUID2_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function custom(requirement, message = "Invalid input") {
  return {
    type: "custom",
    async: false,
    message,
    requirement,
    _parse(input) {
      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function customAsync(requirement, message = "Invalid input") {
  return {
    type: "custom",
    async: true,
    message,
    requirement,
    async _parse(input) {
      return !await this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function email(message = "Invalid email") {
  return {
    type: "email",
    async: false,
    message,
    requirement: EMAIL_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function emoji(message = "Invalid emoji") {
  return {
    type: "emoji",
    async: false,
    message,
    requirement: EMOJI_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function endsWith(requirement, message = "Invalid end") {
  return {
    type: "ends_with",
    async: false,
    message,
    requirement,
    _parse(input) {
      return !input.endsWith(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function equal(requirement, message = "Invalid input") {
  return {
    type: "equal",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function excludes(requirement, message = "Invalid content") {
  return {
    type: "excludes",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.includes(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function finite(message = "Invalid finite number") {
  return {
    type: "finite",
    async: false,
    message,
    requirement: Number.isFinite,
    _parse(input) {
      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function imei(message = "Invalid IMEI") {
  return {
    type: "imei",
    async: false,
    message,
    requirement: [IMEI_REGEX, isLuhnAlgo],
    _parse(input) {
      return !this.requirement[0].test(input) || !this.requirement[1](input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function includes(requirement, message = "Invalid content") {
  return {
    type: "includes",
    async: false,
    message,
    requirement,
    _parse(input) {
      return !input.includes(requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function integer(message = "Invalid integer") {
  return {
    type: "integer",
    async: false,
    message,
    requirement: Number.isInteger,
    _parse(input) {
      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function ip(message = "Invalid IP") {
  return {
    type: "ip",
    async: false,
    message,
    requirement: [IPV4_REGEX, IPV6_REGEX],
    _parse(input) {
      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function ipv4(message = "Invalid IPv4") {
  return {
    type: "ipv4",
    async: false,
    message,
    requirement: IPV4_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function ipv6(message = "Invalid IPv6") {
  return {
    type: "ipv6",
    async: false,
    message,
    requirement: IPV6_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function isoDate(message = "Invalid date") {
  return {
    type: "iso_date",
    async: false,
    message,
    requirement: ISO_DATE_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function isoDateTime(message = "Invalid date-time") {
  return {
    type: "iso_date_time",
    async: false,
    message,
    requirement: ISO_DATE_TIME_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function isoTime(message = "Invalid time") {
  return {
    type: "iso_time",
    async: false,
    message,
    requirement: ISO_TIME_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function isoTimeSecond(message = "Invalid time second") {
  return {
    type: "iso_time_second",
    async: false,
    message,
    requirement: ISO_TIME_SECOND_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function isoTimestamp(message = "Invalid timestamp") {
  return {
    type: "iso_timestamp",
    async: false,
    message,
    requirement: ISO_TIMESTAMP_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function isoWeek(message = "Invalid week") {
  return {
    type: "iso_week",
    async: false,
    message,
    requirement: ISO_WEEK_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function length(requirement, message = "Invalid length") {
  return {
    type: "length",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.length !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function maxBytes(requirement, message = "Invalid byte length") {
  return {
    type: "max_bytes",
    async: false,
    message,
    requirement,
    _parse(input) {
      return new TextEncoder().encode(input).length > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function maxLength(requirement, message = "Invalid length") {
  return {
    type: "max_length",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.length > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function maxSize(requirement, message = "Invalid size") {
  return {
    type: "max_size",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.size > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function maxValue(requirement, message = "Invalid value") {
  return {
    type: "max_value",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
var maxRange = maxValue;
function minBytes(requirement, message = "Invalid byte length") {
  return {
    type: "min_bytes",
    async: false,
    message,
    requirement,
    _parse(input) {
      return new TextEncoder().encode(input).length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function mimeType(requirement, message = "Invalid MIME type") {
  return {
    type: "mime_type",
    async: false,
    message,
    requirement,
    _parse(input) {
      return !this.requirement.includes(input.type) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function minLength(requirement, message = "Invalid length") {
  return {
    type: "min_length",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function minSize(requirement, message = "Invalid size") {
  return {
    type: "min_size",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.size < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function minValue(requirement, message = "Invalid value") {
  return {
    type: "min_value",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
var minRange = minValue;
function multipleOf(requirement, message = "Invalid multiple") {
  return {
    type: "multiple_of",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input % this.requirement !== 0 ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function notBytes(requirement, message = "Invalid byte length") {
  return {
    type: "not_bytes",
    async: false,
    message,
    requirement,
    _parse(input) {
      return new TextEncoder().encode(input).length === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function notLength(requirement, message = "Invalid length") {
  return {
    type: "not_length",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.length === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function notSize(requirement, message = "Invalid size") {
  return {
    type: "not_size",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.size === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function notValue(requirement, message = "Invalid value") {
  return {
    type: "not_value",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function regex(requirement, message = "Invalid regex") {
  return {
    type: "regex",
    async: false,
    message,
    requirement,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function safeInteger(message = "Invalid safe integer") {
  return {
    type: "safe_integer",
    async: false,
    message,
    requirement: Number.isSafeInteger,
    _parse(input) {
      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function size(requirement, message = "Invalid size") {
  return {
    type: "size",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input.size !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function startsWith(requirement, message = "Invalid start") {
  return {
    type: "stars_with",
    async: false,
    message,
    requirement,
    _parse(input) {
      return !input.startsWith(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function ulid(message = "Invalid ULID") {
  return {
    type: "ulid",
    async: false,
    message,
    requirement: ULID_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function url(message = "Invalid URL") {
  return {
    type: "url",
    async: false,
    message,
    requirement(input) {
      try {
        new URL(input);
        return true;
      } catch {
        return false;
      }
    },
    _parse(input) {
      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function uuid(message = "Invalid UUID") {
  return {
    type: "uuid",
    async: false,
    message,
    requirement: UUID_REGEX,
    _parse(input) {
      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
function value(requirement, message = "Invalid value") {
  return {
    type: "value",
    async: false,
    message,
    requirement,
    _parse(input) {
      return input !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
    }
  };
}
export {
  BrandSymbol,
  CUID2_REGEX,
  EMAIL_REGEX,
  EMOJI_REGEX,
  IMEI_REGEX,
  IPV4_REGEX,
  IPV6_REGEX,
  ISO_DATE_REGEX,
  ISO_DATE_TIME_REGEX,
  ISO_TIMESTAMP_REGEX,
  ISO_TIME_REGEX,
  ISO_TIME_SECOND_REGEX,
  ISO_WEEK_REGEX,
  ULID_REGEX,
  UUID_REGEX,
  ValiError,
  any,
  anyAsync,
  array,
  arrayAsync,
  bigint,
  bigintAsync,
  blob,
  blobAsync,
  boolean,
  booleanAsync,
  brand,
  bytes,
  coerce,
  coerceAsync,
  cuid2,
  custom,
  customAsync,
  date,
  dateAsync,
  discriminatedUnion,
  discriminatedUnionAsync,
  email,
  emoji,
  endsWith,
  enumAsync,
  enumType,
  enumTypeAsync,
  enum_,
  equal,
  excludes,
  executePipe,
  executePipeAsync,
  fallback,
  fallbackAsync,
  finite,
  flatten,
  getDefault,
  getDefaultArgs,
  getDefaultAsync,
  getDefaults,
  getDefaultsAsync,
  getFallback,
  getFallbackAsync,
  getFallbacks,
  getFallbacksAsync,
  getIssues,
  getOutput,
  getPipeIssues,
  getRestAndDefaultArgs,
  getSchemaIssues,
  imei,
  includes,
  instance,
  instanceAsync,
  integer,
  intersect,
  intersection,
  ip,
  ipv4,
  ipv6,
  is,
  isLuhnAlgo,
  isoDate,
  isoDateTime,
  isoTime,
  isoTimeSecond,
  isoTimestamp,
  isoWeek,
  keyof,
  length,
  literal,
  literalAsync,
  map,
  mapAsync,
  maxBytes,
  maxLength,
  maxRange,
  maxSize,
  maxValue,
  merge,
  mergeAsync,
  mimeType,
  minBytes,
  minLength,
  minRange,
  minSize,
  minValue,
  multipleOf,
  nan,
  nanAsync,
  nativeEnum,
  nativeEnumAsync,
  never,
  neverAsync,
  nonNullable,
  nonNullableAsync,
  nonNullish,
  nonNullishAsync,
  nonOptional,
  nonOptionalAsync,
  notBytes,
  notLength,
  notSize,
  notValue,
  nullAsync,
  nullType,
  nullTypeAsync,
  null_,
  nullable,
  nullableAsync,
  nullish,
  nullishAsync,
  number,
  numberAsync,
  object,
  objectAsync,
  omit,
  omitAsync,
  optional,
  optionalAsync,
  parse,
  parseAsync,
  partial,
  partialAsync,
  passthrough,
  passthroughAsync,
  pick,
  pickAsync,
  picklist,
  picklistAsync,
  record,
  recordAsync,
  recursive,
  recursiveAsync,
  regex,
  required,
  requiredAsync,
  safeInteger,
  safeParse,
  safeParseAsync,
  set,
  setAsync,
  size,
  special,
  specialAsync,
  startsWith,
  strict,
  strictAsync,
  string,
  stringAsync,
  strip,
  stripAsync,
  symbol,
  symbolAsync,
  toCustom,
  toCustomAsync,
  toLowerCase,
  toMaxValue,
  toMinValue,
  toTrimmed,
  toTrimmedEnd,
  toTrimmedStart,
  toUpperCase,
  transform,
  transformAsync,
  tuple,
  tupleAsync,
  ulid,
  undefinedAsync,
  undefinedType,
  undefinedTypeAsync,
  undefined_,
  union,
  unionAsync,
  unknown,
  unknownAsync,
  unwrap,
  url,
  useDefault,
  uuid,
  value,
  variant,
  variantAsync,
  voidAsync,
  voidType,
  voidTypeAsync,
  void_,
  withDefault
};
//# sourceMappingURL=valibot.js.map
