import { basename, extname } from 'node:path';
import { builtins, builtinOutputFormats, parseURL, extractEntries, resolveConfigs, generateTransforms, applyTransforms, generateImageID, urlFormat, getMetadata, loadImage } from 'imagetools-core';
export * from 'imagetools-core';
import { createFilter, dataToEsm } from '@rollup/pluginutils';

const createBasePath = (base) => {
    return ((base === null || base === void 0 ? void 0 : base.replace(/\/$/, '')) || '') + '/@imagetools/';
};

const defaultOptions = {
    include: /^[^?]+\.(heic|heif|avif|jpeg|jpg|png|tiff|webp|gif)(\?.*)?$/,
    exclude: 'public/**/*',
    removeMetadata: true
};
function imagetools(userOptions = {}) {
    const pluginOptions = { ...defaultOptions, ...userOptions };
    const filter = createFilter(pluginOptions.include, pluginOptions.exclude);
    const transformFactories = pluginOptions.extendTransforms ? pluginOptions.extendTransforms(builtins) : builtins;
    const outputFormats = pluginOptions.extendOutputFormats
        ? pluginOptions.extendOutputFormats(builtinOutputFormats)
        : builtinOutputFormats;
    let viteConfig;
    let basePath;
    const generatedImages = new Map();
    return {
        name: 'imagetools',
        enforce: 'pre',
        configResolved(cfg) {
            viteConfig = cfg;
            basePath = createBasePath(viteConfig.base);
        },
        async load(id) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (!filter(id))
                return null;
            const srcURL = parseURL(id);
            // lazy loaders so that we can load the metadata in defaultDirectives if needed
            // but if there are no directives then we can just skip loading
            let lazyImg;
            const lazyLoadImage = () => {
                if (lazyImg)
                    return lazyImg;
                return (lazyImg = loadImage(decodeURIComponent(srcURL.pathname)));
            };
            let lazyMetadata;
            const lazyLoadMetadata = async () => {
                if (lazyMetadata)
                    return lazyMetadata;
                return (lazyMetadata = await lazyLoadImage().metadata());
            };
            const defaultDirectives = typeof pluginOptions.defaultDirectives === 'function'
                ? await pluginOptions.defaultDirectives(srcURL, lazyLoadMetadata)
                : pluginOptions.defaultDirectives || new URLSearchParams();
            const directives = new URLSearchParams({
                ...Object.fromEntries(defaultDirectives),
                ...Object.fromEntries(srcURL.searchParams)
            });
            if (!directives.toString())
                return null;
            const img = lazyLoadImage();
            if (directives.get('allowUpscale') !== 'true') {
                const metadata = await lazyLoadMetadata();
                const intrinsicWidth = metadata.width || 0;
                const intrinsicHeight = metadata.height || 0;
                const originalWidths = ((_a = directives.get('w')) === null || _a === void 0 ? void 0 : _a.split(';')) || [];
                const widths = originalWidths.filter((d) => parseInt(d) <= intrinsicWidth);
                if (widths.length != originalWidths.length) {
                    if (widths.length) {
                        directives.set('w', widths.join(';'));
                    }
                    else {
                        directives.delete('w');
                    }
                }
                const originalHeights = ((_b = directives.get('h')) === null || _b === void 0 ? void 0 : _b.split(';')) || [];
                const heights = originalHeights.filter((d) => parseInt(d) <= intrinsicHeight);
                if (heights.length != originalHeights.length) {
                    if (heights.length) {
                        directives.set('h', heights.join(';'));
                    }
                    else {
                        directives.delete('h');
                    }
                }
            }
            const parameters = extractEntries(directives);
            const imageConfigs = (_d = (_c = pluginOptions.resolveConfigs) === null || _c === void 0 ? void 0 : _c.call(pluginOptions, parameters, outputFormats)) !== null && _d !== void 0 ? _d : resolveConfigs(parameters, outputFormats);
            const outputMetadatas = [];
            const logger = {
                info: (msg) => viteConfig.logger.info(msg),
                warn: (msg) => this.warn(msg),
                error: (msg) => this.error(msg)
            };
            for (const config of imageConfigs) {
                const { transforms } = generateTransforms(config, transformFactories, srcURL.searchParams, logger);
                const { image, metadata } = await applyTransforms(transforms, img.clone(), pluginOptions.removeMetadata);
                if (viteConfig.command === 'serve') {
                    const id = generateImageID(srcURL, config);
                    generatedImages.set(id, image);
                    metadata.src = basePath + id;
                }
                else {
                    const fileHandle = this.emitFile({
                        name: basename(srcURL.pathname, extname(srcURL.pathname)) + `.${metadata.format}`,
                        source: await image.toBuffer(),
                        type: 'asset'
                    });
                    metadata.src = `__VITE_ASSET__${fileHandle}__`;
                }
                metadata.image = image;
                outputMetadatas.push(metadata);
            }
            let outputFormat = urlFormat();
            const asParam = (_e = directives.get('as')) === null || _e === void 0 ? void 0 : _e.split(':');
            const as = asParam ? asParam[0] : undefined;
            for (const [key, format] of Object.entries(outputFormats)) {
                if (as === key) {
                    outputFormat = format(asParam && asParam[1] ? asParam[1].split(';') : undefined);
                    break;
                }
            }
            return dataToEsm(await outputFormat(outputMetadatas), {
                namedExports: (_g = (_f = viteConfig.json) === null || _f === void 0 ? void 0 : _f.namedExports) !== null && _g !== void 0 ? _g : true,
                compact: (_h = !!viteConfig.build.minify) !== null && _h !== void 0 ? _h : false,
                preferConst: true
            });
        },
        configureServer(server) {
            server.middlewares.use((req, res, next) => {
                var _a;
                if ((_a = req.url) === null || _a === void 0 ? void 0 : _a.startsWith(basePath)) {
                    const [, id] = req.url.split(basePath);
                    const image = generatedImages.get(id);
                    if (!image)
                        throw new Error(`vite-imagetools cannot find image with id "${id}" this is likely an internal error`);
                    if (pluginOptions.removeMetadata === false) {
                        image.withMetadata();
                    }
                    res.setHeader('Content-Type', `image/${getMetadata(image, 'format')}`);
                    res.setHeader('Cache-Control', 'max-age=360000');
                    return image.clone().pipe(res);
                }
                next();
            });
        }
    };
}

export { imagetools };
//# sourceMappingURL=index.js.map
