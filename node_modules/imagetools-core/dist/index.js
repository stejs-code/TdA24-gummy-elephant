import { createHash } from 'node:crypto';
import path from 'node:path';
import sharp from 'sharp';

const METADATA = Symbol('image metadata');
function setMetadata(image, key, value) {
    image[METADATA] && (image[METADATA][key] = value);
}
function getMetadata(image, key) {
    var _a;
    return (_a = image[METADATA]) === null || _a === void 0 ? void 0 : _a[key];
}

const getBackground = ({ background }, image) => {
    if (typeof background !== 'string' || !background.length)
        return;
    setMetadata(image, 'background', background);
    return background;
};

const blur = (config) => {
    let blur = undefined;
    blur = config.blur ? parseFloat(config.blur) : undefined;
    blur || (blur = config.blur === 'true');
    blur || (blur = config.blur === '');
    if (!blur)
        return;
    return function blurTransform(image) {
        setMetadata(image, 'blur', blur);
        return image.blur(blur);
    };
};

const fitValues = ['cover', 'contain', 'fill', 'inside', 'outside'];
const getFit = (config, image) => {
    let fit = undefined;
    if (config.fit && fitValues.includes(config.fit)) {
        fit = config.fit;
    }
    else {
        fit = Object.keys(config).find((k) => fitValues.includes(k) && config[k] === '');
    }
    if (!fit)
        return;
    setMetadata(image, 'fit', fit);
    return fit;
};

const flatten = (config) => {
    if (config.flatten !== '' && config.flatten !== 'true')
        return;
    return function flattenTransform(image) {
        setMetadata(image, 'flatten', true);
        return image.flatten({
            background: getBackground(config, image)
        });
    };
};

const flip = ({ flip }) => {
    if (flip !== '' && flip !== 'true')
        return;
    return function flipTransform(image) {
        setMetadata(image, 'flip', true);
        return image.flip();
    };
};

const flop = ({ flop }) => {
    if (flop !== '' && flop !== 'true')
        return;
    return function flopTransform(image) {
        setMetadata(image, 'flop', true);
        return image.flop();
    };
};

const getQuality = ({ quality: _quality }, image) => {
    const quality = _quality && parseInt(_quality);
    if (!quality)
        return;
    setMetadata(image, 'quality', quality);
    return quality;
};

const getProgressive = ({ progressive }, image) => {
    if (progressive !== '' && progressive !== 'true')
        return;
    setMetadata(image, 'progressive', true);
    return true;
};

const getLossless = ({ lossless }, image) => {
    if (lossless !== '' && lossless !== 'true')
        return;
    setMetadata(image, 'lossless', true);
    return true;
};

const formatValues = ['avif', 'jpg', 'jpeg', 'png', 'heif', 'heic', 'webp', 'tiff'];
const format$1 = (config) => {
    let format = undefined;
    if (config.format && formatValues.includes(config.format)) {
        format = config.format;
    }
    if (!format)
        return;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const fixedFormat = format;
    return function formatTransform(image) {
        setMetadata(image, 'format', format);
        return image.toFormat(fixedFormat, {
            quality: getQuality(config, image),
            lossless: getLossless(config, image),
            progressive: getProgressive(config, image)
        });
    };
};

const grayscale = ({ grayscale }) => {
    if (grayscale !== '' && grayscale !== 'true')
        return;
    return function grayscaleTransform(image) {
        setMetadata(image, 'grayscale', true);
        return image.grayscale();
    };
};

const hsb = (config) => {
    const hue = config.hue && parseInt(config.hue);
    const saturation = config.saturation && parseFloat(config.saturation);
    const brightness = config.brightness && parseFloat(config.brightness);
    if (!hue && !saturation && !brightness)
        return;
    return function hsbTransform(image) {
        setMetadata(image, 'hue', hue);
        setMetadata(image, 'saturation', saturation);
        setMetadata(image, 'brightness', brightness);
        return image.modulate({
            hue: hue || 0,
            saturation: saturation || 1,
            brightness: brightness || 1
        });
    };
};

const invert = ({ invert }) => {
    if (invert !== '' && invert !== 'true')
        return;
    return function invertTransform(image) {
        setMetadata(image, 'invert', true);
        return image.negate();
    };
};

const kernelValues = ['nearest', 'cubic', 'mitchell', 'lanczos2', 'lanczos3'];
const getKernel = ({ kernel }, image) => {
    if (kernel && kernelValues.includes(kernel)) {
        setMetadata(image, 'kernel', kernel);
        return kernel;
    }
};

const median = (config) => {
    const median = config.median ? parseInt(config.median) : undefined;
    if (!median)
        return;
    return function medianTransform(image) {
        setMetadata(image, 'median', median);
        return image.median(median);
    };
};

const normalize = ({ normalize }) => {
    if (normalize !== '' && normalize !== 'true')
        return;
    return function normalizeTransform(image) {
        setMetadata(image, 'normalize', true);
        return image.normalize();
    };
};

const positionValues = [
    'top',
    'right top',
    'right',
    'right bottom',
    'bottom',
    'left bottom',
    'left',
    'left top',
    'north',
    'northeast',
    'east',
    'southeast',
    'south',
    'southwest',
    'west',
    'northwest',
    'center',
    'centre',
    'entropy',
    'attention'
];
const positionShorthands = [
    'top',
    'right top',
    'right',
    'right bottom',
    'bottom',
    'left bottom',
    'left',
    'left top'
];
const getPosition = (config, image) => {
    let position = undefined;
    if (config.position && positionValues.includes(config.position)) {
        position = config.position;
    }
    else {
        position = Object.keys(config).find((k) => positionShorthands.includes(k) && config[k] === '');
    }
    if (!position)
        return;
    setMetadata(image, 'position', position);
    return position;
};

/**
 * This function parses a user provided aspect-ratio string into a float.
 * Valid syntaxes are `16:9` or `1.777`
 * @param aspect
 * @returns
 */
function parseAspect(aspect) {
    const parts = aspect.split(':');
    let aspectRatio;
    if (parts.length === 1) {
        // the string was a float
        aspectRatio = parseFloat(parts[0]);
    }
    else if (parts.length === 2) {
        // the string was a colon delimited aspect ratio
        const [width, height] = parts.map((str) => parseInt(str));
        if (!width || !height)
            return undefined;
        aspectRatio = width / height;
    }
    if (!aspectRatio || aspectRatio <= 0)
        return undefined;
    return aspectRatio;
}
const resize = (config, context) => {
    const width = parseInt(config.w || '');
    const height = parseInt(config.h || '');
    const aspect = parseAspect(config.aspect || '');
    const allowUpscale = config.allowUpscale === '' || config.allowUpscale === 'true';
    if (!width && !height && !aspect)
        return;
    return function resizeTransform(image) {
        const fit = getFit(config, image);
        // calculate finalWidth & finalHeight
        const originalWidth = getMetadata(image, 'width');
        const originalHeight = getMetadata(image, 'height');
        const originalAspect = originalWidth / originalHeight;
        let finalWidth = width, finalHeight = height, finalAspect = aspect;
        if (aspect && !width && !height) {
            // only aspect was given, need to calculate which dimension to crop
            if (aspect > originalAspect) {
                finalHeight = originalWidth / aspect;
                finalWidth = originalWidth;
            }
            else {
                finalHeight = originalHeight;
                finalWidth = originalHeight / aspect;
            }
        }
        else if (width && height) {
            // width & height BOTH given, need to look at fit
            switch (fit) {
                case 'inside':
                    if (width / height < originalAspect) {
                        finalHeight = width / originalAspect;
                    }
                    else {
                        finalWidth = height * originalAspect;
                    }
                    break;
                case 'outside':
                    if (width / height > originalAspect) {
                        finalHeight = width / originalAspect;
                    }
                    else {
                        finalWidth = height * originalAspect;
                    }
                    break;
            }
            finalAspect = finalWidth / finalHeight;
        }
        else if (!height) {
            // only width was provided, need to calculate height
            finalAspect = aspect || originalAspect;
            finalHeight = width / finalAspect;
        }
        else if (!width) {
            // only height was provided, need to calculate width
            finalAspect = aspect || originalAspect;
            finalWidth = height * finalAspect;
        }
        if (!allowUpscale && (finalHeight > originalHeight || finalWidth > originalWidth)) {
            finalHeight = originalHeight;
            finalWidth = originalWidth;
            finalAspect = originalAspect;
            if (context.manualSearchParams.has('width') || context.manualSearchParams.has('height')) {
                context.logger.info('allowUpscale not enabled. Image width, height and aspect ratio reverted to original values');
            }
        }
        finalWidth = Math.round(finalWidth);
        finalHeight = Math.round(finalHeight);
        setMetadata(image, 'height', finalHeight);
        setMetadata(image, 'width', finalWidth);
        setMetadata(image, 'aspect', finalAspect);
        setMetadata(image, 'allowUpscale', allowUpscale);
        return image.resize({
            width: finalWidth || undefined,
            height: finalHeight || undefined,
            withoutEnlargement: !allowUpscale,
            fit,
            position: getPosition(config, image),
            kernel: getKernel(config, image),
            background: getBackground(config, image)
        });
    };
};

const rotate = (config) => {
    const rotate = config.rotate && parseInt(config.rotate);
    if (!rotate)
        return;
    return function rotateTransform(image) {
        setMetadata(image, 'rotate', rotate);
        return image.rotate(rotate, {
            background: getBackground(config, image)
        });
    };
};

const tint = ({ tint }) => {
    if (typeof tint !== 'string' || !tint.length)
        return;
    return function tintTransform(image) {
        setMetadata(image, 'tint', '#' + tint);
        return image.tint('#' + tint);
    };
};

const builtins = [
    blur,
    flatten,
    flip,
    flop,
    format$1,
    grayscale,
    hsb,
    invert,
    median,
    normalize,
    resize,
    rotate,
    tint
];

const urlFormat = () => (metadatas) => {
    const urls = metadatas.map((metadata) => metadata.src);
    return urls.length == 1 ? urls[0] : urls;
};
const srcsetFormat = () => (metadatas) => {
    const sources = metadatas.map((meta) => `${meta.src} ${meta.width}w`);
    return sources.join(', ');
};
const metadataFormat = (whitelist) => (metadatas) => {
    if (whitelist) {
        metadatas = metadatas.map((cfg) => Object.fromEntries(Object.entries(cfg).filter(([k]) => whitelist.includes(k))));
    }
    metadatas.forEach((m) => delete m.image);
    return metadatas.length === 1 ? metadatas[0] : metadatas;
};
const metadataToSource = (m) => ({ src: m.src, w: m.width });
/** normalizes the format for use in mime-type */
const format = (m) => m.format.replace('jpg', 'jpeg');
const sourceFormat = () => (metadatas) => {
    return metadatas.map((m) => metadataToSource(m));
};
const imgFormat = () => (metadatas) => {
    let largestImage;
    let largestImageSize = 0;
    for (let i = 0; i < metadatas.length; i++) {
        const m = metadatas[i];
        if (m.width > largestImageSize) {
            largestImage = m;
            largestImageSize = m.width;
        }
    }
    const result = {
        src: largestImage === null || largestImage === void 0 ? void 0 : largestImage.src,
        w: largestImage === null || largestImage === void 0 ? void 0 : largestImage.width,
        h: largestImage === null || largestImage === void 0 ? void 0 : largestImage.height
    };
    if (metadatas.length >= 2) {
        result.srcset = [];
        for (let i = 0; i < metadatas.length; i++) {
            result.srcset.push(metadataToSource(metadatas[i]));
        }
    }
    return result;
};
/** fallback format should be specified last */
const pictureFormat = () => (metadatas) => {
    const fallbackFormat = [...new Set(metadatas.map((m) => format(m)))].pop();
    let largestFallback;
    let largestFallbackSize = 0;
    let fallbackFormatCount = 0;
    for (let i = 0; i < metadatas.length; i++) {
        const m = metadatas[i];
        if (format(m) === fallbackFormat) {
            fallbackFormatCount++;
            if (m.width > largestFallbackSize) {
                largestFallback = m;
                largestFallbackSize = m.width;
            }
        }
    }
    const sources = {};
    for (let i = 0; i < metadatas.length; i++) {
        const m = metadatas[i];
        const f = format(m);
        // we don't need to create a source tag for the fallback format if there is
        // only a single image in that format
        if (f === fallbackFormat && fallbackFormatCount < 2) {
            continue;
        }
        if (sources[f]) {
            sources[f].push(metadataToSource(m));
        }
        else {
            sources[f] = [metadataToSource(m)];
        }
    }
    const result = {
        sources,
        // the fallback should be the largest image in the fallback format
        // we assume users should never upsize an image because that is just wasted
        // bytes since the browser can upsize just as well
        img: {
            src: largestFallback === null || largestFallback === void 0 ? void 0 : largestFallback.src,
            w: largestFallback === null || largestFallback === void 0 ? void 0 : largestFallback.width,
            h: largestFallback === null || largestFallback === void 0 ? void 0 : largestFallback.height
        }
    };
    return result;
};
const builtinOutputFormats = {
    url: urlFormat,
    source: sourceFormat,
    srcset: srcsetFormat,
    img: imgFormat,
    picture: pictureFormat,
    metadata: metadataFormat,
    meta: metadataFormat
};

function loadImage(path) {
    return sharp(path);
}
function generateImageID(url, config) {
    // this isn't a valid URL, but just a string used for an identifier
    // use a relative path in the local case so that it's consistent across machines
    const baseURL = url.host
        ? new URL(url.origin + url.pathname)
        : new URL(url.protocol + path.relative(process.cwd(), url.pathname));
    return createHash('sha1').update(baseURL.href).update(JSON.stringify(config)).digest('hex');
}

function parseURL(rawURL) {
    return new URL(rawURL.replace(/#/g, '%23'), 'file://');
}
function extractEntries(searchParams) {
    const entries = [];
    for (const [key, value] of searchParams) {
        const values = value.includes(':') ? [value] : value.split(';');
        entries.push([key, values]);
    }
    return entries;
}

/**
 * This function calculates the cartesian product of two or more arrays and is straight from stackoverflow ;)
 * Should be replaced with something more legible but works for now.
 */
const cartesian = (...a) => 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
a.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, e].flat())));
/**
 * This function builds up all possible combinations the given entries can be combined
 * and returns it as an array of objects that can be given to a the transforms.
 * @param entries The url parameter entries
 * @returns An array of directive options
 */
function resolveConfigs(entries, outputFormats) {
    // create a new array of entries for each argument
    const singleArgumentEntries = entries
        .filter(([k]) => !(k in outputFormats))
        .map(([key, values]) => values.map((v) => [[key, v]]));
    // do a cartesian product on all entries to get all combinations we need to produce
    const combinations = singleArgumentEntries
        // .filter(([key]) => !(key[0][0] in outputFormats))
        .reduce((prev, cur) => (prev.length ? cartesian(prev, cur) : cur), []);
    const metadataAddons = entries.filter(([k]) => k in outputFormats);
    // and return as an array of objects
    const out = combinations.map((options) => Object.fromEntries([...options, ...metadataAddons]));
    return out.length ? out : [Object.fromEntries(metadataAddons)];
}

const consoleLogger = {
    info(msg) {
        console.info(msg);
    },
    warn(msg) {
        console.warn(msg);
    },
    error(msg) {
        console.error(msg);
    }
};

function generateTransforms(config, factories, manualSearchParams, logger) {
    if (logger === undefined) {
        logger = consoleLogger;
    }
    const transforms = [];
    const parametersUsed = new Set();
    const context = {
        useParam: (k) => parametersUsed.add(k),
        manualSearchParams,
        logger
    };
    for (const directive of factories) {
        const transform = directive(config, context);
        if (typeof transform === 'function')
            transforms.push(transform);
    }
    return {
        transforms,
        parametersUsed
    };
}

async function applyTransforms(transforms, image, removeMetadata = true) {
    image[METADATA] = await image.metadata();
    if (removeMetadata) {
        // delete the private metadata
        delete image[METADATA].exif;
        delete image[METADATA].iptc;
        delete image[METADATA].xmp;
        delete image[METADATA].tifftagPhotoshop;
        delete image[METADATA].icc;
    }
    else {
        image.withMetadata();
    }
    for (const transform of transforms) {
        image = await transform(image);
    }
    return {
        image,
        metadata: image[METADATA]
    };
}

export { applyTransforms, blur, builtinOutputFormats, builtins, extractEntries, fitValues, flatten, flip, flop, format$1 as format, formatValues, generateImageID, generateTransforms, getBackground, getFit, getKernel, getLossless, getMetadata, getPosition, getProgressive, getQuality, grayscale, hsb, imgFormat, invert, kernelValues, loadImage, median, metadataFormat, normalize, parseURL, pictureFormat, positionShorthands, positionValues, resize, resolveConfigs, rotate, setMetadata, sourceFormat, srcsetFormat, tint, urlFormat };
//# sourceMappingURL=index.js.map
