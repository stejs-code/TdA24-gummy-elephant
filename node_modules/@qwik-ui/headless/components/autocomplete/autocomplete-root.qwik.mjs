import { componentQrl, inlinedQrl, _restProps, useVisibleTaskQrl, useStore, useSignal, useId, useContextProvider, useLexicalScope, useOnWindow, _jsxS, _jsxC, Slot } from "@builder.io/qwik";
import { computePosition, flip } from "@floating-ui/dom";
import AutocompleteContextId from "./autocomplete-context-id.qwik.mjs";
const AutocompleteRoot = /* @__PURE__ */ componentQrl(/* @__PURE__ */ inlinedQrl((props) => {
  const props1 = _restProps(props, [
    "defaultValue"
  ]);
  useVisibleTaskQrl(/* @__PURE__ */ inlinedQrl(function deprecatedComponentError() {
    throw new Error("Qwik UI: The Autocomplete component has been deprecated in favor of the Combobox. Please use the Combobox component instead.");
  }, "AutocompleteRoot_component_useVisibleTask_YM0YQy6ylMI"));
  const optionsStore = useStore([]);
  const filteredOptionsStore = useStore([]);
  const selectedOptionSig = useSignal(props.defaultValue ? props.defaultValue : "");
  const isTriggerExpandedSig = useSignal(false);
  const inputRefSig = useSignal();
  const triggerRefSig = useSignal();
  const listBoxRefSig = useSignal();
  const rootRef = useSignal();
  const labelRef = useSignal();
  const inputValueSig = useSignal(props.defaultValue ? props.defaultValue : "");
  const listBoxId = useId();
  const inputId = useId();
  const triggerId = useId();
  const activeOptionId = useSignal(null);
  const isInputFocusedSig = useSignal(false);
  const focusInput$ = /* @__PURE__ */ inlinedQrl((inputId2) => {
    const [rootRef2] = useLexicalScope();
    rootRef2.value?.querySelector(`[data-autocomplete-input-id="${inputId2}"]`)?.focus();
  }, "AutocompleteRoot_component_focusInput_ympUatoO4zs", [
    rootRef
  ]);
  const dataHolder = useSignal([]);
  console.log(dataHolder.value);
  const contextService = {
    dataHolder,
    optionsStore,
    filteredOptionsStore,
    selectedOptionSig,
    isTriggerExpandedSig,
    inputRefSig,
    triggerRefSig,
    listBoxRefSig,
    labelRef,
    inputValueSig,
    listBoxId,
    inputId,
    triggerId,
    activeOptionId,
    focusInput$,
    isInputFocusedSig
  };
  useContextProvider(AutocompleteContextId, contextService);
  const updatePosition = /* @__PURE__ */ inlinedQrl((referenceEl, floatingEl) => {
    computePosition(referenceEl, floatingEl, {
      placement: "bottom",
      middleware: [
        flip()
      ]
    }).then(({ x, y }) => {
      Object.assign(floatingEl.style, {
        left: `${x}px`,
        top: `${y}px`
      });
    });
  }, "AutocompleteRoot_component_updatePosition_C1fynSf09uw");
  useVisibleTaskQrl(/* @__PURE__ */ inlinedQrl(async function updatePositionTask({ track }) {
    const [inputRefSig2, isTriggerExpandedSig2, listBoxRefSig2, updatePosition2] = useLexicalScope();
    const inputRefValue = track(() => inputRefSig2.value);
    const listBox = track(() => listBoxRefSig2.value);
    const expanded = track(() => isTriggerExpandedSig2.value);
    if (!inputRefValue || !listBox)
      return;
    if (expanded === true)
      await updatePosition2(inputRefValue, listBox);
  }, "AutocompleteRoot_component_useVisibleTask_1_PDFlHYpiwiY", [
    inputRefSig,
    isTriggerExpandedSig,
    listBoxRefSig,
    updatePosition
  ]));
  useVisibleTaskQrl(/* @__PURE__ */ inlinedQrl(function filterOptionsTask({ track }) {
    const [contextService2, inputValueSig2, isInputFocusedSig2] = useLexicalScope();
    track(() => inputValueSig2.value);
    contextService2.filteredOptionsStore = contextService2.optionsStore.filter((option) => {
      const optionValue = option.value.getAttribute("optionValue");
      const defaultFilter = new RegExp(inputValueSig2.value, "i");
      if (isInputFocusedSig2.value) {
        if (optionValue === inputValueSig2.value)
          contextService2.isTriggerExpandedSig.value = false;
        else if (optionValue.match(defaultFilter))
          contextService2.isTriggerExpandedSig.value = true;
      } else
        contextService2.isTriggerExpandedSig.value = false;
      return optionValue.match(defaultFilter);
    });
    contextService2.optionsStore.map((option) => {
      if (!option.value.getAttribute("optionValue").match(new RegExp(inputValueSig2.value, "i")))
        option.value.style.display = "none";
      else
        option.value.style.display = "";
    });
  }, "AutocompleteRoot_component_useVisibleTask_2_N74uWMuubK0", [
    contextService,
    inputValueSig,
    isInputFocusedSig
  ]));
  useOnWindow("click", /* @__PURE__ */ inlinedQrl((e) => {
    const [contextService2] = useLexicalScope();
    const target = e.target;
    if (contextService2.isTriggerExpandedSig.value === true && !contextService2.listBoxRefSig.value?.contains(target) && !contextService2.triggerRefSig.value?.contains(target))
      contextService2.isTriggerExpandedSig.value = false;
  }, "AutocompleteRoot_component_useOnWindow_nlwR8BFcQiY", [
    contextService
  ]));
  return /* @__PURE__ */ _jsxS("div", {
    ...props1,
    children: /* @__PURE__ */ _jsxC(Slot, null, 3, "XJ_0"),
    onKeyDown$: [
      /* @__PURE__ */ inlinedQrl((e) => {
        const [contextService2] = useLexicalScope();
        if (e.key === "Escape") {
          contextService2.isTriggerExpandedSig.value = false;
          const inputElement = contextService2.inputRefSig.value?.firstElementChild;
          inputElement?.focus();
        }
      }, "AutocompleteRoot_component_div_onKeyDown_sTRTEBYUlQc", [
        contextService
      ]),
      props1.onKeyDown$
    ],
    ref: rootRef
  }, null, 0, "XJ_1");
}, "AutocompleteRoot_component_vXjTqQMRfek"));
export {
  AutocompleteRoot
};
