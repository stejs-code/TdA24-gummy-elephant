"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const qwik = require("@builder.io/qwik");
const utils = require("./utils.qwik.cjs");
const useVisible = (ref) => {
  const first = qwik.useSignal(0);
  const last = qwik.useSignal(0);
  const trackVisible = /* @__PURE__ */ qwik.inlinedQrl(async (map) => {
    const items = Array.from(map);
    let start = 0;
    let end = 0;
    items.forEach(([, visible], i) => {
      if (i === 0 && visible)
        start = 0;
      const next = items.at(i + 1)?.[1];
      if (!visible && next)
        start = i + 1;
      if (visible && !next)
        end = i;
    });
    return {
      start,
      end
    };
  }, "useVisible_trackVisible_ASQcAhU0NT4");
  qwik.useVisibleTaskQrl(/* @__PURE__ */ qwik.inlinedQrl(async function trackActiveItems() {
    const [first2, last2, ref2, trackVisible2] = qwik.useLexicalScope();
    const map = /* @__PURE__ */ new Map();
    utils.getElements(ref2).forEach((element) => map.set(element, void 0));
    const observer = new IntersectionObserver((nodes) => {
      nodes.forEach(async (item) => {
        map.set(item.target, item.isIntersecting);
        const { start, end } = await trackVisible2(map);
        first2.value = start;
        last2.value = end;
      });
    }, {
      root: utils.getContainer(ref2)
    });
    utils.getElements(ref2).forEach((item) => observer.observe(item));
  }, "useVisible_useVisibleTask_0nEd0KoWmT8", [
    first,
    last,
    ref,
    trackVisible
  ]));
  return {
    first,
    last
  };
};
exports.useVisible = useVisible;
